/***************************************************
 * semdiag: draw SEM path diagram interactively    *
 * Authors: Yujiao Mai, Zhiyong Zhang, Ke-Hai Yuan *
 * Copyright 2015-2015, psychstat.org              *
 * Licensed under the MIT License (MIT)            *
 * Current software version 1.0                    *
 * Support email for questions zzhang4@nd.edu      *
 *                             ymai@nd.edu         * 
 ***************************************************/
function NewNode() {
    var a;
    return a = {
        id: "",
        type: "rect",
        x: nodeInitialPos.x,
        y: nodeInitialPos.y,
        rx: default_RADIUSH,
        ry: default_RADIUSV,
        color: defaultCOLOR,
        dotted: 0,
        title: "X",
        fontsize: defaultFONTSIZE,
        strokewidth: default_strokeWIDTH,
        selected: !1,
        level: 1
    }
}

function NewEdge() {
    var a;
    return a = {
        id: "",
        power: 2,
        type: "uni",
        nodeid: "",
        startid: "",
        endid: "",
        handleP: {
            x: -1,
            y: -1
        },
        cP: {
            x: -1,
            y: -1
        },
        theta: selfpathTHETA_default,
        P0: {
            x: -1,
            y: -1
        },
        P1: {
            x: -1,
            y: -1
        },
        P2: {
            x: -1,
            y: -1
        },
        P3: {
            x: -1,
            y: -1
        },
        line: "",
        curve_LR: default_selfcurve_LR,
        color: defaultCOLOR,
        dotted: 0,
        strokewidth: default_strokeWIDTH,
        label: "",
        labelP: {
            x: -1,
            y: -1
        },
        labelFsize: defaultFONTSIZE,
        labelInitial: !0,
        labelshow: !0,
        handleInitial: !0,
        handlePshow: !1,
        IsAutoGenerated: !1,
        selected: !1
    }
}

function NewNote() {
    var a;
    return a = {
        id: "",
        x: default_RADIUSH,
        y: default_RADIUSV,
        color: defaultCOLOR,
        text: "",
        fontsize: defaultFONTSIZE,
        selected: !1
    }
}

function matchnodeindex(a, b) {
    for (var c = -1, d = 0; d < a.length; d++)
        if (a[d].id === b) return c = d;
    return c
}

function matchedgeindex(a, b) {
    for (var c = -1, d = 0; d < a.length; d++)
        if (a[d].id === b) return c = d;
    return c
}

function matchnoteindex(a, b) {
    for (var c = -1, d = 0; d < a.length; d++)
        if (a[d].id === b) return c = d;
    return c
}

function generate_resize_cPs(a) {
    for (var b = [], c = 0; c < a.length; c++) {
        var d = a[c],
            e = d.rx,
            f = d.ry;
        switch (d.type) {
            case "ellipse":
                var g = {
                        x: d.x - e - 2 * cPr,
                        y: d.y
                    },
                    h = {
                        x: d.x + e + 2 * cPr,
                        y: d.y
                    },
                    i = {
                        x: d.x,
                        y: d.y - f - 2 * cPr
                    },
                    j = {
                        x: d.x,
                        y: d.y + f + 2 * cPr
                    },
                    k = {
                        nodeid: d.id,
                        pos: g,
                        type: "left"
                    },
                    l = {
                        nodeid: d.id,
                        pos: h,
                        type: "right"
                    },
                    m = {
                        nodeid: d.id,
                        pos: i,
                        type: "top"
                    },
                    n = {
                        nodeid: d.id,
                        pos: j,
                        type: "bottom"
                    };
                b.push(k), b.push(l), b.push(m), b.push(n);
                break;
            case "rect":
                var g = {
                        x: d.x - e - 2 * cPr,
                        y: d.y
                    },
                    h = {
                        x: d.x + e + 2 * cPr,
                        y: d.y
                    },
                    i = {
                        x: d.x,
                        y: d.y - f - 2 * cPr
                    },
                    j = {
                        x: d.x,
                        y: d.y + f + 2 * cPr
                    },
                    k = {
                        nodeid: d.id,
                        pos: g,
                        type: "left"
                    },
                    l = {
                        nodeid: d.id,
                        pos: h,
                        type: "right"
                    },
                    m = {
                        nodeid: d.id,
                        pos: i,
                        type: "top"
                    },
                    n = {
                        nodeid: d.id,
                        pos: j,
                        type: "bottom"
                    };
                b.push(k), b.push(l), b.push(m), b.push(n);
                break;
            case "triangle":
                var i = {
                        x: d.x,
                        y: d.y - f - 2 * cPr
                    },
                    o = {
                        x: d.x - e * Math.sqrt(3) / 2 - 2 * cPr,
                        y: d.y + f / 2 + 2 * cPr
                    },
                    p = {
                        x: d.x + e * Math.sqrt(3) / 2 + 2 * cPr,
                        y: d.y + f / 2 + 2 * cPr
                    },
                    k = {
                        nodeid: d.id,
                        pos: i,
                        type: "top"
                    },
                    l = {
                        nodeid: d.id,
                        pos: o,
                        type: "left_bottom"
                    },
                    m = {
                        nodeid: d.id,
                        pos: p,
                        type: "right_bottom"
                    };
                b.push(k), b.push(l), b.push(m)
        }
    }
    return b
}

function generate_label(a, b, c, d) {
    var e = "";
    return e
}

function cal_labelP(a, b, c, d, e, f) {
    var g = {
        x: a.x + 15,
        y: a.y - 15
    };
    switch (d) {
        case 2:
            g = null !== e & null !== f ? {
                x: a.x + e,
                y: a.y + f
            } : {
                x: a.x + 15,
                y: a.y - 15
            };
            break;
        case 3:
            a.x < b.x ? g.x = a.x - 20 : a.x > b.x ? g.x = a.x + 15 : g.x = a.x, a.y < b.y ? g.y = a.y - 15 : a.y > b.y ? g.y = a.y + 20 : g.y = a.y
    }
    return g
}

function generate_bcurve2p(a, b, c, d) {
    var e = null,
        f = matchnodeindex(a, b),
        g = matchnodeindex(a, c),
        h = {
            x: a[f].x,
            y: a[f].y
        },
        i = {
            x: a[g].x,
            y: a[g].y
        },
        j = {
            x: (h.x + i.x) / 2,
            y: (h.y + i.y) / 2
        },
        k = {
            x: 2 * j.x - (h.x + i.x) / 2,
            y: 2 * j.y - (h.y + i.y) / 2
        },
        l = "M" + h.x + " " + h.y + " Q" + k.x + " " + k.y + " " + i.x + " " + i.y,
        m = generate_label(a[f], a[g], d, 2),
        n = cal_labelP(j, h, i, 2, null, null),
        e = {
            id: "edge" + String(Edgecurrent_IdNUM),
            power: 2,
            startid: b,
            endid: c,
            handleP: j,
            cP: k,
            line: l,
            type: d,
            dotted: 0,
            color: defaultCOLOR,
            strokewidth: default_strokeWIDTH,
            label: m,
            labelP: n,
            labelFsize: defaultFONTSIZE,
            labelInitial: !0,
            labelshow: !0,
            handlePshow: !1,
            handleInitial: !0,
            IsAutoGenerated: !1,
            curve_LR: default_selfcurve_LR,
            selected: !1
        };
    return e
}

function generate_bcurve3p(a, b, c) {
    var d = null,
        e = selfpathTHETA_default,
        f = selfpathANGLE_default,
        g = matchnodeindex(a, b),
        h = a[g],
        i = default_selfcurve_LR,
        j = 0,
        k = 0;
    switch (h.type) {
        case "ellipse":
            var l = h.rx,
                m = h.ry;
            j = l * m / Math.sqrt(m * Math.cos(e) * (m * Math.cos(e)) + l * Math.sin(e) * (l * Math.sin(e)));
            break;
        case "rect":
            var j = 0,
                n = Math.atan(h.ry / h.rx);
            e >= n & e <= Math.PI - n ? j = Math.abs(h.ry / Math.sin(e)) : e >= 2 * Math.PI - n & e <= 2 * Math.PI || e >= 0 & e <= n ? j = Math.abs(h.rx / Math.cos(e)) : e >= Math.PI + n & e <= 2 * Math.PI - n ? j = Math.abs(h.ry / Math.sin(e)) : e >= Math.PI - n & e <= Math.PI + n && (j = Math.abs(h.rx / Math.cos(e)));
            break;
        case "triangle":
            var o = {
                    x: h.x - h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                p = {
                    x: h.x + h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                q = {
                    x: h.x,
                    y: h.y - h.ry
                },
                r = {
                    P1: o,
                    P2: p
                },
                s = {
                    P1: q,
                    P2: p
                },
                t = {
                    P1: o,
                    P2: q
                },
                u = (r.P2.y - r.P1.y) / (r.P2.x - r.P1.x),
                v = (s.P2.y - s.P1.y) / (s.P2.x - s.P1.x),
                w = (t.P2.y - t.P1.y) / (t.P2.x - t.P1.x),
                x = {
                    A: u,
                    B: -1,
                    C: r.P1.y - u * r.P1.x
                },
                y = {
                    A: v,
                    B: -1,
                    C: s.P1.y - v * s.P1.x
                },
                z = {
                    A: w,
                    B: -1,
                    C: t.P1.y - w * t.P1.x
                };
            if (e % (Math.PI / 2) === 0) var A = {
                A: 1,
                B: 0,
                C: -h.x
            };
            else var B = Math.tan(e),
                A = {
                    A: B,
                    B: -1,
                    C: h.y - B * h.x
                };
            var C = {};
            e >= Math.PI / 6 & e <= 5 * Math.PI / 6 ? C = interP_2lines(x.A, x.B, x.C, A.A, A.B, A.C) : e >= 3 * Math.PI / 2 & e <= 2 * Math.PI || e >= 0 & e <= 1 * Math.PI / 6 ? C = interP_2lines(y.A, y.B, y.C, A.A, A.B, A.C) : e >= 5 * Math.PI / 6 & e <= 3 * Math.PI / 2 && (C = interP_2lines(z.A, z.B, z.C, A.A, A.B, A.C)), 1 === C.numsolution && (j = Math.sqrt((C.interP.x - h.x) * (C.interP.x - h.x) + (C.interP.y - h.y) * (C.interP.y - h.y)))
    }
    k = j - default_RADIUSH * newr_DISCOUNT;
    var D = h.x + k * Math.cos(e),
        E = h.y + k * Math.sin(e),
        F = {
            x: D,
            y: E
        },
        G = F,
        H = {
            x: D + i * Math.cos(e + f),
            y: E + i * Math.sin(e + f)
        },
        I = {
            x: D + i * Math.cos(e - f),
            y: E + i * Math.sin(e - f)
        },
        J = {
            x: 1 * F.x / 8 + 3 * H.x * 1 / 8 + 3 * I.x * 1 / 8 + 1 * G.x / 8,
            y: 1 * F.y / 8 + 3 * H.y * 1 / 8 + 3 * I.y * 1 / 8 + 1 * G.y / 8
        },
        K = "M" + F.x + " " + F.y + " C" + H.x + " " + H.y + " " + I.x + " " + I.y + " " + G.x + " " + G.y,
        L = generate_label(h, h, c, 3),
        M = {
            x: h.x,
            y: h.y
        },
        N = cal_labelP(J, M, M, 3, null, null),
        d = {
            id: "edge" + String(Edgecurrent_IdNUM),
            power: 3,
            nodeid: b,
            startid: b,
            endid: b,
            theta: e,
            handleP: J,
            P0: F,
            P1: H,
            P2: I,
            P3: G,
            line: K,
            type: c,
            dotted: 0,
            color: defaultCOLOR,
            strokewidth: default_strokeWIDTH,
            label: L,
            labelP: N,
            labelFsize: defaultFONTSIZE,
            labelInitial: !0,
            labelshow: !0,
            curve_LR: i,
            handlePshow: !1,
            handleInitial: !0,
            IsAutoGenerated: !1,
            selected: !1
        };
    return d
}

function generate_edge(a, b, c, d) {
    var e = null;
    if (b === c) {
        var f = b;
        e = generate_bcurve3p(a, f, d)
    } else e = generate_bcurve2p(a, b, c, d);
    return e
}

function update_bcurve2p(a, b, reset=true) {
    var c = matchnodeindex(a, b.startid),
        d = matchnodeindex(a, b.endid),
        e = {
            x: a[c].x,
            y: a[c].y
        },
        f = {
            x: a[d].x,
            y: a[d].y
        },
        g = b.handleP,
        h = b.handleInitial,
        i = {
            x: 2 * g.x - (e.x + f.x) / 2,
            y: 2 * g.y - (e.y + f.y) / 2
        },
        j = "M" + e.x + " " + e.y + " Q" + i.x + " " + i.y + " " + f.x + " " + f.y;
        k=b.labelP;
        if (reset){
            k = cal_labelP(g, e, f, 2, null, null);
        }
       
        l = {
            id: b.id,
            power: 2,
            startid: b.startid,
            endid: b.endid,
            handleP: g,
            cP: i,
            line: j,
            type: b.type,
            dotted: b.dotted,
            color: b.color,
            strokewidth: b.strokewidth,
            label: b.label,
            labelP: k,
            labelFsize: b.labelFsize,
            labelInitial: b.labelInitial,
            labelshow: b.labelshow,
            handlePshow: b.handlePshow,
            handleInitial: h,
            curve_LR: b.curve_LR,
            IsAutoGenerated: b.IsAutoGenerated,
            selected: b.selected
        };
    return l
}

function update_bcurve3p(a, b, c, d, reset=true) {
    var e = b.nodeid,
        f = matchnodeindex(a, e),
        g = a[f],
        h = b.curve_LR,
        i = 0,
        j = 0;
    switch (g.type) {
        case "ellipse":
            var k = g.rx,
                l = g.ry;
            i = k * l / Math.sqrt(l * Math.cos(c) * (l * Math.cos(c)) + k * Math.sin(c) * (k * Math.sin(c)));
            break;
        case "rect":
            var i = 0,
                m = Math.atan(g.ry / g.rx);
            c >= m & c <= Math.PI - m ? i = Math.abs(g.ry / Math.sin(c)) : c >= 2 * Math.PI - m & c <= 2 * Math.PI || c >= 0 & c <= m ? i = Math.abs(g.rx / Math.cos(c)) : c >= Math.PI + m & c <= 2 * Math.PI - m ? i = Math.abs(g.ry / Math.sin(c)) : c >= Math.PI - m & c <= Math.PI + m && (i = Math.abs(g.rx / Math.cos(c)));
            break;
        case "triangle":
            var n = {
                    x: g.x - g.rx * Math.sqrt(3) / 2,
                    y: g.y + g.rx / 2
                },
                o = {
                    x: g.x + g.rx * Math.sqrt(3) / 2,
                    y: g.y + g.rx / 2
                },
                p = {
                    x: g.x,
                    y: g.y - g.ry
                },
                q = {
                    P1: n,
                    P2: o
                },
                r = {
                    P1: p,
                    P2: o
                },
                s = {
                    P1: n,
                    P2: p
                },
                t = (q.P2.y - q.P1.y) / (q.P2.x - q.P1.x),
                u = (r.P2.y - r.P1.y) / (r.P2.x - r.P1.x),
                v = (s.P2.y - s.P1.y) / (s.P2.x - s.P1.x),
                w = {
                    A: t,
                    B: -1,
                    C: q.P1.y - t * q.P1.x
                },
                x = {
                    A: u,
                    B: -1,
                    C: r.P1.y - u * r.P1.x
                },
                y = {
                    A: v,
                    B: -1,
                    C: s.P1.y - v * s.P1.x
                };
            if (c % (Math.PI / 2) === 0) var z = {
                A: 1,
                B: 0,
                C: g.x
            };
            else var A = Math.tan(c),
                z = {
                    A: A,
                    B: -1,
                    C: g.y - A * g.x
                };
            var B = {};
            c >= Math.PI / 6 & c <= 5 * Math.PI / 6 ? B = interP_2lines(w.A, w.B, w.C, z.A, z.B, z.C) : c >= 3 * Math.PI / 2 & c <= 2 * Math.PI || c >= 0 & c <= 1 * Math.PI / 6 ? B = interP_2lines(x.A, x.B, x.C, z.A, z.B, z.C) : c >= 5 * Math.PI / 6 & c <= 3 * Math.PI / 2 && (B = interP_2lines(y.A, y.B, y.C, z.A, z.B, z.C)), 1 === B.numsolution && (i = Math.sqrt((B.interP.x - g.x) * (B.interP.x - g.x) + (B.interP.y - g.y) * (B.interP.y - g.y)))
    }
    j = i - default_RADIUSH * newr_DISCOUNT;
    var C = g.x + j * Math.cos(c),
        D = g.y + j * Math.sin(c),
        E = {
            x: C,
            y: D
        },
        F = E,
        G = {
            x: C + h * Math.cos(c + d),
            y: D + h * Math.sin(c + d)
        },
        H = {
            x: C + h * Math.cos(c - d),
            y: D + h * Math.sin(c - d)
        },
        E = {
            x: C,
            y: D
        },
        F = E,
        G = {
            x: C + h * Math.cos(c + d),
            y: D + h * Math.sin(c + d)
        },
        H = {
            x: C + h * Math.cos(c - d),
            y: D + h * Math.sin(c - d)
        },
        I = {
            x: 1 * E.x / 8 + 3 * G.x * 1 / 8 + 3 * H.x * 1 / 8 + 1 * F.x / 8,
            y: 1 * E.y / 8 + 3 * G.y * 1 / 8 + 3 * H.y * 1 / 8 + 1 * F.y / 8
        },
        J = "M" + E.x + " " + E.y + " C" + G.x + " " + G.y + " " + H.x + " " + H.y + " " + F.x + " " + F.y,
        L = {
            x: g.x,
            y: g.y
        },
        M =b.labelP;
        if (reset){
            M = cal_labelP(I, L, L, 3, null, null);
        }
       
        N = {
            id: b.id,
            power: 3,
            nodeid: e,
            startid: e,
            endid: e,
            theta: c,
            handleP: I,
            P0: E,
            P1: G,
            P2: H,
            P3: F,
            line: J,
            type: b.type,
            dotted: b.dotted,
            color: b.color,
            strokewidth: b.strokewidth,
            label: b.label,
            labelP: M,
            labelFsize: b.labelFsize,
            labelInitial: b.labelInitial,
            labelshow: b.labelshow,
            curve_LR: b.curve_LR,
            handlePshow: b.handlePshow,
            handleInitial: b.handleInitial,
            IsAutoGenerated: b.IsAutoGenerated,
            selected: !1
        };
    return N
}

function update_bcurve(a, b, reset=true) {
    var c = null;
    if (2 === b.power) {
        var d;
        if (reset){ d=update_bcurve2p(a, b);}else{
            d=update_bcurve2p(a, b, reset=false);
        }
        c = d
    } else if (3 === b.power) {
        var e = b.nodeid,
            f = matchnodeindex(a, e),
            g = a[f],
            h = {
                x: g.x,
                y: g.y
            },
            i = b.handleP,
            j = 0;
        j = calculate_theta(h, i);

        var k;
        if (reset){ k=update_bcurve3p(a, b, j, selfpathANGLE_default);}else{
            k=update_bcurve3p(a, b, j, selfpathANGLE_default, reset=false);
        }
        //var k = update_bcurve3p(a, b, j, selfpathANGLE_default);
        c = k
    }
    return c
}

function update_edges(a, b) {
    for (var c = [], d = 0; d < b.length; d++) c.push(update_bcurve(a, b[d]));
    return c
}

function lookfor_duplicatedbcurve(a, b, c, d, e) {
    for (var f = -1, g = 0; g < b.length; g++)
        if (3 === b[g].power) {
            if (b[g].nodeid === c & b[g].nodeid === d & b[g].type === e) return f = g
        } else if (2 === b[g].power) switch (e) {
        case "bi":
            if (b[g].startid === c & b[g].endid === d & b[g].type === e) return f = g;
            if (b[g].startid === d & b[g].endid === c & b[g].type === e) return f = g;
            break;
        case "uni":
            if (b[g].startid === c & b[g].endid === d & b[g].type === e) return f = g
    }
    return f
}

function Is_dependentnode(a, b, c) {
    for (var d = !1, e = 0; e < c.length; e++)
        if (2 === c[e].power & "uni" === c[e].type) {
            var f = b[matchnodeindex(b, c[e].startid)],
                g = b[matchnodeindex(b, c[e].endid)];
            a.id === g.id & ("rect" === f.type || "ellipse" === f.type) && (d = !0, e = edges.length)
        } return d
}

function lookup_interP_with_oneNode_bcurve2p(a, b, c) {
    if ("startP" === c) var d = 0,
        e = 1,
        f = 1 / Nt,
        g = 2,
        h = a[matchnodeindex(a, b.startid)];
    else if ("endP" === c) var d = 1,
        e = 0,
        f = -1 / Nt,
        g = -1,
        h = a[matchnodeindex(a, b.endid)];
    var i = {
            x: h.x + h.rx,
            y: h.y + h.ry
        },
        j = d + .001,
        k = {
            x: h.x + 60,
            y: h.y + 60
        },
        l = d + .002,
        m = !1,
        n = a[matchnodeindex(a, b.startid)],
        o = a[matchnodeindex(a, b.endid)],
        p = b.cP;
    switch (h.type) {
        case "ellipse":
            var q = h.rx,
                r = h.ry,
                s = {
                    x: h.x,
                    y: h.y
                },
                t = !1,
                u = d,
                v = u;
            for ("endP" === c ? v = -1 * u : "startP" === c && (v = u); v <= e;) {
                var w = (1 - u) * (1 - u) * n.x + 2 * u * (1 - u) * p.x + u * u * o.x,
                    x = (1 - u) * (1 - u) * n.y + 2 * u * (1 - u) * p.y + u * u * o.y,
                    y = {
                        x: w,
                        y: x
                    };
                if (y.x <= s.x - q || y.x >= s.x + q || y.y <= s.y - r || y.y >= s.y + r ? t = !0 : (y.x - s.x) * (y.x - s.x) / (q * q) + (y.y - s.y) * (y.y - s.y) / (r * r) >= 1 && (t = !0), t) {
                    m = !0, i = y, j = u, u = g, l = j + 50 * f;
                    var z = (1 - l) * (1 - l) * n.x + 2 * l * (1 - l) * p.x + l * l * o.x,
                        A = (1 - l) * (1 - l) * n.y + 2 * l * (1 - l) * p.y + l * l * o.y;
                    k = {
                        x: z,
                        y: A
                    }
                }
                u += f, v = u, "endP" === c ? v = -1 * u : "startP" === c && (v = u)
            }
            break;
        case "rect":
            var B = {
                    x: h.x - h.rx,
                    y: h.y - h.ry
                },
                C = {
                    x: h.x + h.rx,
                    y: h.y - h.ry
                },
                D = {
                    x: h.x + h.rx,
                    y: h.y + h.ry
                },
                E = {
                    x: h.x - h.rx,
                    y: h.y + h.ry
                },
                G = {
                    P1: C,
                    P2: D
                },
                H = {
                    P1: E,
                    P2: D
                },
                t = !1,
                u = d,
                v = u;
            for ("endP" === c ? v = -1 * u : "startP" === c && (v = u); v <= e;) {
                var w = (1 - u) * (1 - u) * n.x + 2 * u * (1 - u) * p.x + u * u * o.x,
                    x = (1 - u) * (1 - u) * n.y + 2 * u * (1 - u) * p.y + u * u * o.y,
                    y = {
                        x: w,
                        y: x
                    };
                if ((y.x <= h.x - h.rx || y.x >= h.x + h.rx || y.y <= h.y - h.ry || y.y >= h.y + h.ry) && (t = !0), t) {
                    m = !0, i = y, j = u, u = g, l = j + 50 * f;
                    var z = (1 - l) * (1 - l) * n.x + 2 * l * (1 - l) * p.x + l * l * o.x,
                        A = (1 - l) * (1 - l) * n.y + 2 * l * (1 - l) * p.y + l * l * o.y;
                    k = {
                        x: z,
                        y: A
                    }
                }
                u += f, v = u, "endP" === c ? v = -1 * u : "startP" === c && (v = u)
            }
            break;
        case "triangle":
            var B = {
                    x: h.x - h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                C = {
                    x: h.x + h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                D = {
                    x: h.x,
                    y: h.y - h.ry
                },
                G = {
                    P1: D,
                    P2: C
                },
                H = {
                    P1: B,
                    P2: D
                },
                t = !1,
                u = d,
                v = u;
            for ("endP" === c ? v = -1 * u : "startP" === c && (v = u); v <= e;) {
                var w = (1 - u) * (1 - u) * n.x + 2 * u * (1 - u) * p.x + u * u * o.x,
                    x = (1 - u) * (1 - u) * n.y + 2 * u * (1 - u) * p.y + u * u * o.y,
                    y = {
                        x: w,
                        y: x
                    };
                if (y.x <= h.x - h.rx * Math.sqrt(3) / 2 || y.x >= h.x + h.rx * Math.sqrt(3) / 2 || y.y <= h.y - h.ry || y.y >= h.y + h.rx / 2) t = !0;
                else {
                    var J, K = G.P1.y,
                        L = (G.P2.y - G.P1.y) / (G.P2.x - G.P1.x),
                        M = H.P1.y,
                        N = (H.P2.y - H.P1.y) / (H.P2.x - H.P1.x);
                    J = y.x <= h.x ? M + N * (y.x - H.P1.x) : K + L * (y.x - G.P1.x), y.y <= J && (t = !0)
                }
                if (t) {
                    m = !0, i = y, j = u, u = g, l = j + 50 * f;
                    var z = (1 - l) * (1 - l) * n.x + 2 * l * (1 - l) * p.x + l * l * o.x,
                        A = (1 - l) * (1 - l) * n.y + 2 * l * (1 - l) * p.y + l * l * o.y;
                    k = {
                        x: z,
                        y: A
                    }
                }
                u += f, v = u, "endP" === c ? v = -1 * u : "startP" === c && (v = u)
            }
    }
    var O = {
        Isfound: m,
        interP: i,
        inter_t: j,
        interP_out: k,
        inter_t_out: l
    };
    return O
}

function lookup_interP_with_oneNode_bcurve3p(a, b, c) {
    if ("startP" === c) var d = 0,
        e = 1,
        f = 1 / Nt,
        g = 2;
    else if ("endP" === c) var d = 1,
        e = 0,
        f = -1 / Nt,
        g = -1;
    var h = a[matchnodeindex(a, b.nodeid)],
        i = {
            x: h.x + h.rx,
            y: h.y + h.ry
        },
        j = d + .001,
        k = {
            x: h.x + 60,
            y: h.y + 60
        },
        l = d + .002,
        m = !1,
        n = b.P0,
        o = b.P1,
        p = b.P2,
        q = b.P3;
    switch (h.type) {
        case "ellipse":
            var r = h.rx,
                s = h.ry,
                t = {
                    x: h.x,
                    y: h.y
                },
                u = !1,
                v = d,
                w = v;
            for ("endP" === c ? w = -1 * v : "startP" === c && (w = v); w <= e;) {
                var x = (1 - v) * (1 - v) * (1 - v) * n.x + 3 * (1 - v) * (1 - v) * v * o.x + 3 * (1 - v) * v * v * p.x + v * v * v * q.x,
                    y = (1 - v) * (1 - v) * (1 - v) * n.y + 3 * (1 - v) * (1 - v) * v * o.y + 3 * (1 - v) * v * v * p.y + v * v * v * q.y,
                    z = {
                        x: x,
                        y: y
                    };
                if (z.x <= t.x - r || z.x >= t.x + r || z.y <= t.y - s || z.y >= t.y + s ? u = !0 : (z.x - t.x) * (z.x - t.x) / (r * r) + (z.y - t.y) * (z.y - t.y) / (s * s) >= 1 && (u = !0), u) {
                    m = !0, i = z, j = v, v = g, l = j + 50 * f;
                    var A = (1 - l) * (1 - l) * (1 - l) * n.x + 3 * (1 - l) * (1 - l) * l * o.x + 3 * (1 - l) * l * l * p.x + l * l * l * q.x,
                        B = (1 - l) * (1 - l) * (1 - l) * n.y + 3 * (1 - l) * (1 - l) * l * o.y + 3 * (1 - l) * l * l * p.y + l * l * l * q.y;
                    k = {
                        x: A,
                        y: B
                    }
                }
                v += f, w = v, "endP" === c ? w = -1 * v : "startP" === c && (w = v)
            }
            break;
        case "rect":
            var C = {
                    x: h.x - h.rx,
                    y: h.y - h.ry
                },
                D = {
                    x: h.x + h.rx,
                    y: h.y - h.ry
                },
                E = {
                    x: h.x + h.rx,
                    y: h.y + h.ry
                },
                F = {
                    x: h.x - h.rx,
                    y: h.y + h.ry
                },
                H = {
                    P1: D,
                    P2: E
                },
                I = {
                    P1: F,
                    P2: E
                },
                u = !1,
                v = d,
                w = v;
            for ("endP" === c ? w = -1 * v : "startP" === c && (w = v); w <= e;) {
                var x = (1 - v) * (1 - v) * (1 - v) * n.x + 3 * (1 - v) * (1 - v) * v * o.x + 3 * (1 - v) * v * v * p.x + v * v * v * q.x,
                    y = (1 - v) * (1 - v) * (1 - v) * n.y + 3 * (1 - v) * (1 - v) * v * o.y + 3 * (1 - v) * v * v * p.y + v * v * v * q.y,
                    z = {
                        x: x,
                        y: y
                    };
                if ((z.x <= h.x - h.rx || z.x >= h.x + h.rx || z.y <= h.y - h.ry || z.y >= h.y + h.ry) && (u = !0), u) {
                    m = !0, i = z, j = v, v = g, l = j + 50 * f;
                    var A = (1 - l) * (1 - l) * (1 - l) * n.x + 3 * (1 - l) * (1 - l) * l * o.x + 3 * (1 - l) * l * l * p.x + l * l * l * q.x,
                        B = (1 - l) * (1 - l) * (1 - l) * n.y + 3 * (1 - l) * (1 - l) * l * o.y + 3 * (1 - l) * l * l * p.y + l * l * l * q.y;
                    k = {
                        x: A,
                        y: B
                    }
                }
                v += f, w = v, "endP" === c ? w = -1 * v : "startP" === c && (w = v)
            }
            break;
        case "triangle":
            var C = {
                    x: h.x - h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                D = {
                    x: h.x + h.rx * Math.sqrt(3) / 2,
                    y: h.y + h.rx / 2
                },
                E = {
                    x: h.x,
                    y: h.y - h.ry
                },
                H = {
                    P1: E,
                    P2: D
                },
                I = {
                    P1: C,
                    P2: E
                },
                u = !1,
                v = d,
                w = v;
            for ("endP" === c ? w = -1 * v : "startP" === c && (w = v); w <= e;) {
                var x = (1 - v) * (1 - v) * (1 - v) * n.x + 3 * (1 - v) * (1 - v) * v * o.x + 3 * (1 - v) * v * v * p.x + v * v * v * q.x,
                    y = (1 - v) * (1 - v) * (1 - v) * n.y + 3 * (1 - v) * (1 - v) * v * o.y + 3 * (1 - v) * v * v * p.y + v * v * v * q.y,
                    z = {
                        x: x,
                        y: y
                    };
                if (z.x <= h.x - h.rx * Math.sqrt(3) / 2 || z.x >= h.x + h.rx * Math.sqrt(3) / 2 || z.y <= h.y - h.ry || z.y >= h.y + h.rx / 2) u = !0;
                else {
                    var K, L = H.P1.y,
                        M = (H.P2.y - H.P1.y) / (H.P2.x - H.P1.x),
                        N = I.P1.y,
                        O = (I.P2.y - I.P1.y) / (I.P2.x - I.P1.x);
                    K = z.x <= h.x ? N + O * (z.x - I.P1.x) : L + M * (z.x - H.P1.x), z.y <= K && (u = !0)
                }
                if (u) {
                    m = !0, i = z, j = v, v = g, l = j + 50 * f;
                    var A = (1 - l) * (1 - l) * (1 - l) * n.x + 3 * (1 - l) * (1 - l) * l * o.x + 3 * (1 - l) * l * l * p.x + l * l * l * q.x,
                        B = (1 - l) * (1 - l) * (1 - l) * n.y + 3 * (1 - l) * (1 - l) * l * o.y + 3 * (1 - l) * l * l * p.y + l * l * l * q.y;
                    k = {
                        x: A,
                        y: B
                    }
                }
                v += f, w = v, "endP" === c ? w = -1 * v : "startP" === c && (w = v)
            }
    }
    var P = {
        Isfound: m,
        interP: i,
        inter_t: j,
        interP_out: k,
        inter_t_out: l
    };
    return P
}

function generate_tangent_bcurve2p(a, b) {
    var c = lookup_interP_with_oneNode_bcurve2p(a, b, "startP"),
        d = lookup_interP_with_oneNode_bcurve2p(a, b, "endP"),
        g = (c.Isfound, d.Isfound, c.interP),
        h = d.interP,
        k = (c.inter_t, d.inter_t, c.interP_out),
        l = d.interP_out,
        q = (c.inter_t_out, d.inter_t_out, {
            startid: b.startid,
            endid: b.endid,
            type: b.type,
            interP1: g,
            interP2: h,
            interP_out1: k,
            interP_out2: l,
            tangentline1: "M" + k.x + "," + k.y + " L" + g.x + "," + g.y,
            tangentline2: "M" + l.x + "," + l.y + " L" + h.x + "," + h.y
        });
    return q
}

function generate_tangent_bcurve3p(a, b) {
    var c = lookup_interP_with_oneNode_bcurve3p(a, b, "startP"),
        d = lookup_interP_with_oneNode_bcurve3p(a, b, "endP"),
        g = (c.Isfound, d.Isfound, c.interP),
        h = d.interP,
        k = (c.inter_t, d.inter_t, c.interP_out),
        l = d.interP_out,
        q = (c.inter_t_out, d.inter_t_out, {
            startid: b.nodeid,
            endid: b.nodeid,
            type: b.type,
            interP1: g,
            interP2: h,
            interP_out1: k,
            interP_out2: l,
            tangentline1: "M" + k.x + "," + k.y + " L" + g.x + "," + g.y,
            tangentline2: "M" + l.x + "," + l.y + " L" + h.x + "," + h.y
        });
    return q
}

function generate_tangent(a, b) {
    var c = null;
    return 2 === b.power ? c = generate_tangent_bcurve2p(a, b) : 3 === b.power && (c = generate_tangent_bcurve3p(a, b)), c
}

function generate_tangents(a, b) {
    for (var c = [], d = 0; d < b.length; d++) {
        var e = null;
        e = generate_tangent(a, b[d]), c.push(e)
    }
    return c
}

function generate_new_handleP_for_movednode(a, b, c, d) {
    var e = b.handleP,
        f = matchnodeindex(a, b.startid),
        g = matchnodeindex(a, b.endid),
        h = {
            x: a[f].x,
            y: a[f].y
        },
        i = {
            x: a[g].x,
            y: a[g].y
        },
        j = b.handleP;
    switch (c) {
        case "startP":
            var k = calculate_angles_of_triangle(d, j, i);
            break;
        case "endP":
            var k = calculate_angles_of_triangle(h, j, d);
            break;
        default:
            var k = calculate_angles_of_triangle(d, j, i)
    }
    if (k.Is_success) {
        var l = k.angle_P0,
            m = k.angle_P2,
            o = (k.angle_P1, k.angle_anticlockwise);
        switch (c) {
            case "startP":
                var x, p = {
                        P1: d,
                        P2: j
                    },
                    q = Math.sqrt((p.P2.x - p.P1.x) * (p.P2.x - p.P1.x) + (p.P2.y - p.P1.y) * (p.P2.y - p.P1.y)),
                    r = {
                        P1: d,
                        P2: i
                    },
                    s = Math.sqrt((r.P2.x - r.P1.x) * (r.P2.x - r.P1.x) + (r.P2.y - r.P1.y) * (r.P2.y - r.P1.y)),
                    t = {
                        P1: h,
                        P2: i
                    },
                    u = Math.sqrt((t.P2.x - t.P1.x) * (t.P2.x - t.P1.x) + (t.P2.y - t.P1.y) * (t.P2.y - t.P1.y)),
                    v = q * u / s,
                    w = Math.acos((t.P2.x - t.P1.x) / u);
                x = t.P2.y >= t.P1.y ? w : 2 * Math.PI - w;
                var y;
                y = o ? x + l : x - l;
                var z = t.P1.x + v * Math.cos(y),
                    A = t.P1.y + v * Math.sin(y);
                e = {
                    x: z,
                    y: A
                };
                break;
            case "endP":
                var J, B = {
                        P1: d,
                        P2: j
                    },
                    C = Math.sqrt((B.P2.x - B.P1.x) * (B.P2.x - B.P1.x) + (B.P2.y - B.P1.y) * (B.P2.y - B.P1.y)),
                    D = {
                        P1: d,
                        P2: h
                    },
                    E = Math.sqrt((D.P2.x - D.P1.x) * (D.P2.x - D.P1.x) + (D.P2.y - D.P1.y) * (D.P2.y - D.P1.y)),
                    F = {
                        P1: i,
                        P2: h
                    },
                    G = Math.sqrt((F.P2.x - F.P1.x) * (F.P2.x - F.P1.x) + (F.P2.y - F.P1.y) * (F.P2.y - F.P1.y)),
                    H = C * G / E,
                    I = Math.acos((F.P2.x - F.P1.x) / G);
                J = F.P2.y >= F.P1.y ? I : 2 * Math.PI - I;
                var K;
                K = o ? J - m : J + m;
                var z = F.P1.x + H * Math.cos(K),
                    A = F.P1.y + H * Math.sin(K);
                e = {
                    x: z,
                    y: A
                }
        }
    }
    return e
}