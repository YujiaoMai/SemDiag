/***************************************************
 * semdiag: draw SEM path diagram interactively    *
 * Authors: Yujiao Mai, Zhiyong Zhang, Ke-Hai Yuan *
 * Copyright 2015-2015, psychstat.org              *
 * Licensed under the MIT License (MIT)            *     
 ***************************************************/
function NewNode(){
	var newnode;
	var t_id='';
	var t_type='ellipse';
	var t_x=default_RADIUSH;
	var t_y=default_RADIUSV;
	var t_rx=default_RADIUSH;
	var t_ry=default_RADIUSV;
	var t_color=defaultCOLOR;
	var t_dotted='none';
	var t_title='';
	var t_fontsize=defaultFONTSIZE;
	var t_strokewidth=default_strokeWIDTH;
	var t_selected=false;
	newnode={
		id:t_id,
		type:t_type,
		x:Number(t_x),
		y:Number(t_y),
		rx:Number(t_rx),
		ry:Number(t_ry),
		color:t_color,
		strokedotted:Number(t_dotted),
		title:t_title,
		fontsize:Number(t_fontsize),
		strokewidth:Number(t_strokewidth),
		selected:t_selected
	};
	return newnode;
}

function NewEdge(){
	var newedg;
					var t_id='';
					var t_type='';
					var t_power=2;
					var t_node1='';
					var t_node2='';
					var t_handlePx=-1;
					var t_handelPy=-1;
					var t_color=defaultCOLOR;
					var t_dotted='none';
					var t_strokewidth=default_strokeWIDTH;
					var t_label='';
					var t_labelPx=-1;
					var t_labelPy=-1;
					var t_labelFsize =defaultFONTSIZE;
					var t_labelInitial = true;
					var t_curve_LR=-1;
					var t_handleInitial=true;
					var t_IsAutoGenerated=false;
					var t_selected=false;
  newedge={
		id:t_id,
		power:t_power,
		type:t_type,
		startid:t_node1,
		endid:t_node2,
		handlePx:t_handlePx,
		handlePy:t_handelPy,
		color:t_color,
		dotted:t_dotted,
		strokewidth:t_strokewidth,
		label:t_label,
		labelPx:t_labelPx,
		labelPy:t_labelPy,
		labelFsize:t_labelFsize,
		labelInitial:t_labelInitial,
		curve_LR:t_curve_LR,
		handleInitial:t_handleInitial,
		IsAutoGenerated: t_IsAutoGenerated,
		selected:t_selected
  };
  return newedge;
}

function NewNote(){
	var newnote;
	var t_x=default_RADIUSH;
	var t_y=default_RADIUSV;
	var t_color=defaultCOLOR;
	var t_text='';
	var t_fontsize=defaultFONTSIZE;
	var t_selected=false;
	newnote={
		id:'',
		x:Number(t_x),
		y:Number(t_y),
		color:t_color,
		text:t_text,
		fontsize:Number(t_fontsize),
		selected:t_selected
	};
	return newnote;
}


//函数：根据id查找节点，返回目标node的index
function matchnodeindex(_nodes, _nodeid) {
	var temp=-1;
	for (var i=0; i < _nodes.length; i++){
		if (_nodes[i].id ===_nodeid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//找不到匹配的id 就返回-1
}

//函数：根据id查找节点，返回目标edge的index
function matchedgeindex(_edges, _edgeid) {
	var temp=-1;
	for (var i=0; i < _edges.length; i++){
		if (_edges[i].id ===_edgeid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//找不到匹配的id 就返回-1
}

//函数：根据id查找节点，返回目标note的index
function matchnoteindex(_notes, _noteid) {
	var temp=-1;
	for (var i=0; i < _notes.length; i++){
		if (_notes[i].id ===_noteid) {
			temp = i;
			return temp;
		}		
	}
	return temp;	//找不到匹配的id 就返回-1
}

//函数：给定的节点组，生成resize的控制点
function generate_resize_cPs(_nodes){
	var resize_cPs = [];
	for (var i = 0; i < _nodes.length; i++){
		var _node = _nodes[i];
		var rx = _node.rx;
		var ry = _node.ry;
		switch (_node.type){
			case "ellipse":
				{
					var leftP = {x: _node.x -rx - 2*cPr, y: _node.y };
					var rightP = {x: _node.x + rx + 2*cPr , y: _node.y};
					var topP = {x: _node.x , y: _node.y - ry - 2*cPr };
					var bottomP = {x: _node.x, y: _node.y + ry + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:leftP,
							type:"left"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP4 = {
							nodeid: _node.id,
							pos:bottomP,
							type:"bottom"							
						};
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);
					resize_cPs.push(cP4);
				}
				break;
			case "rect":
				{
					var leftP = {x: _node.x -rx - 2*cPr, y: _node.y };
					var rightP = {x: _node.x + rx + 2*cPr , y: _node.y};
					var topP = {x: _node.x , y: _node.y - ry - 2*cPr };
					var bottomP = {x: _node.x, y: _node.y + ry + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:leftP,
							type:"left"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP4 = {
							nodeid: _node.id,
							pos:bottomP,
							type:"bottom"							
						};
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);
					resize_cPs.push(cP4);
				}
				break;
			case "triangle":
				{
					var topP = {x: _node.x, y: _node.y - ry - 2*cPr };
					var left_bottom_P = {x: _node.x - rx * Math.sqrt(3)/2 - 2*cPr, y: _node.y + ry /2 + 2*cPr};
					var right_bottom_P = {x: _node.x + rx * Math.sqrt(3)/2 + 2*cPr, y: _node.y + ry /2 + 2*cPr };
					var cP1 = {
							nodeid: _node.id,
							pos:topP,
							type:"top"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:left_bottom_P,
							type:"left_bottom"							
						};
					var cP3 = {
							nodeid: _node.id,
							pos:right_bottom_P,
							type:"right_bottom"							
						};
				
					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
					resize_cPs.push(cP3);				
				}
				break;
			case "diamond":
				{
					var leftP = { x: _node.x - rx - 2*cPr, y: _node.y  };
					var rightP = { x: _node.x + rx + 2*cPr, y: _node.y};
					var cP1 = {
							nodeid: _node.id,
							pos:leftP,
							type:"left"							
						};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};

					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
				}
				break;
			case "hexagon":
				{
					var leftP = { x: _node.x - rx - 2*cPr,		y: _node.y };
					var rightP = { x: _node.x + rx + 2*cPr,       y: _node.y };
										var cP1 = {
					nodeid: _node.id,
					pos:leftP,
					type:"left"							
					};
					var cP2 = {
							nodeid: _node.id,
							pos:rightP,
							type:"right"							
						};

					resize_cPs.push(cP1);
					resize_cPs.push(cP2);
				}
				break;
			default:;
		}
	}
	return resize_cPs;
}

function generate_label(_startnode, _endnode, _ArrowType, _bcurvePower){ //console.log("generate_label() begin:");
	var _startnodeType=_startnode.type;
	var _endnodeType = _endnode.type;
	var _startnodeTitle = _startnode.title;
	var _endnodeTitle = _endnode.title;
	var label="a_"+_startnodeTitle+"_"+_endnodeTitle;
	switch(_ArrowType){
		case "bi": 
			if (_bcurvePower===2){
				label ="r_"+_startnodeTitle+"_"+_endnodeTitle;
			} else if (_bcurvePower===3){
				label ="e_"+_startnodeTitle;
			}
			break;
		case "uni":
			if (_startnodeType ==="triangle" ){
				label = "u_"+ _endnodeTitle;
			} else if ( _startnodeType ==="diamond"){
				label = "d_"+_endnodeTitle;
			} else if (_startnodeType==="ellipse" & _endnodeType === "rect"){
				label ="l_"+_startnodeTitle+"_"+_endnodeTitle;
			} else {
				label ="b_"+_startnodeTitle+"_"+_endnodeTitle;
			}
			break;
		default:label="a_"+_startnodeTitle+"_"+_endnodeTitle;
	}
	return label;
}

function cal_labelP(_handleP, _node1P, _node2P, _power){ //console.log("cal_labelP() begin:");
	var templabelP = {x:_handleP.x+15, y: _handleP.y-15};
	switch(_power){
		case 2:
			templabelP = {x:_handleP.x+15, y: _handleP.y-15};
		break;
		case 3: 
		{
			if (_handleP.x < _node1P.x) {
				templabelP.x = _handleP.x - 20;
			} else if (_handleP.x > _node1P.x){
				templabelP.x = _handleP.x + 15;
			} else {
				templabelP.x = _handleP.x;
			}
			if (_handleP.y < _node1P.y) {
				templabelP.y = _handleP.y - 15;
			} else if (_handleP.y > _node1P.y){
				templabelP.y = _handleP.y + 20;
			} else {
				templabelP.y = _handleP.y;
			}			
		}
		break;
		default:;
	}//end of switch
	return templabelP;
}	

//函数： 生成一条二次B曲线
function generate_bcurve2p(_nodes,_startid, _endid,  _arrowType){ //console.log("generate_bcurve2p(): _nodes: ");console.log(_nodes);
		var tempbcurve2p = null;
		var _i=matchnodeindex(_nodes,_startid);
		var _j=matchnodeindex(_nodes,_endid);	
		var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
		var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
		var _handleP = { x:(_startP.x + _endP.x)/2,  y:(_startP.y + _endP.y)/2	};
		var tempcP = {x: _handleP.x * 2 - (_startP.x + _endP.x) / 2, y: _handleP.y * 2 - (_startP.y + _endP.y) / 2};
		var templine = "M"+ _startP.x + " " + _startP.y + " " + "Q" + tempcP.x+" " + tempcP.y + " " + _endP.x+" " + _endP.y ;
		//var templabel= "a"+ _i +"_"+ _j;
		var templabel = generate_label(_nodes[_i], _nodes[_j], _arrowType, 2);
		var templabelP = cal_labelP(_handleP, _startP, _endP, 2);
		var tempbcurve2p={
			id:"edge"+String(Edgecurrent_IdNUM),
			power:2,
			startid: _startid,
			endid: _endid,
			handleP:_handleP,
			cP:tempcP,
			line: templine,			
			type: _arrowType, //type of path default = "bidirectional"
			dotted: 0, //dotted or real line
			color:defaultCOLOR,
			strokewidth:default_strokeWIDTH,
			label: templabel,
			labelP: templabelP,
			labelFsize: defaultFONTSIZE,
			labelInitial:true,
			labelshow: true,
			handlePshow: false,
			handleInitial:true, //marks down if the path has been curved 1: straight 0:curved
			IsAutoGenerated: false,
			curve_LR:default_selfcurve_LR,
			selected:false
		};
		return tempbcurve2p;
}

//函数：产生一条三次B曲线 //用作 self correlation var 函数：生成自连曲线 power 3
function generate_bcurve3p(_nodes,_nodeid, _arrowType){ //generate by setting the nodes' ids 			
	var tempbcurve3p = null;
	var _theta = selfpathTHETA_default;
	var _Angle = selfpathANGLE_default;
	var i =matchnodeindex(_nodes,_nodeid);
	var targetnode=_nodes[i];
	var selfcurve_LR=default_selfcurve_LR;
	//use another idea: inner same figure bound as the track for the bcurve3p's P0 and P3
	var current_r=0;
	var newr=0;
	switch(targetnode.type){
		case "ellipse": {
			//var current_P = {x: targetnode.x + targetnode.rx * Math.cos(_theta), y: targetnode.y + targetnode.ry * Math.sin(_theta)};
			//current_r =  Math.sqrt((current_P.x - targetnode.x)*(current_P.x - targetnode.x)  
			//						+ (current_P.y - targetnode.y)*(current_P.y - targetnode.y));
			var aa=targetnode.rx;
			var bb=targetnode.ry;
			current_r = aa * bb / Math.sqrt( (bb * Math.cos(_theta) ) * (bb * Math.cos(_theta) ) +  (aa * Math.sin(_theta)) *(aa * Math.sin(_theta)) )
			//console.log("current_r "+ current_r);			
		}
			break;
		case "rect":{  
			var current_r = 0;
			//var p1 = {x:targetnode.x - targetnode.rx, y: targetnode.y - targetnode.ry};
			//var p2 = {x:targetnode.x + targetnode.rx, y: targetnode.y - targetnode.ry};
			//var p3 = {x:targetnode.x + targetnode.rx, y: targetnode.y + targetnode.ry};
			//var p4 = {x:targetnode.x - targetnode.rx, y: targetnode.y + targetnode.ry};
			//var line1 = {P1: p1, P2:p2};//rectalpha interval [rectalpha, Math.PI-rectalpha]
			//var line2 = {P1: p2, P2:p3};//[2* Math.PI - rectalpha, 2* Math.PI] & [0, rectalpha] 										
			//var line3 = {P1: p4, P2:p3};//[Math.PI+ rectalpha, 2* Math.PI - rectalpha]										
			//var line4 = {P1: p1, P2:p4};//[Math.PI- rectalpha, Math.PI + rectalpha]			
			var rectalpha = Math.atan(targetnode.ry / targetnode.rx); 
			//console.log("rectalpha");console.log(rectalpha);
			//console.log("_theta");console.log(_theta);
			//console.log("Math.PI" + Math.PI);
			if (_theta >= rectalpha & _theta <= Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );//console.log("_theta >= rectalpha & _theta <= Math.PI - rectalpha");
			} else if ( (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) || (_theta >= 0 & _theta<= rectalpha)){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );// console.log("if (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) | (_theta >= 0 <= rectalpha)");
			} else if (_theta >= Math.PI+ rectalpha & _theta <= 2* Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if (_theta >= Math.PI- rectalpha & _theta <= Math.PI + rectalpha){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			}
		} 
			break;
		case "triangle":{		
				var p1 = { x: targetnode.x - targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p2 = { x: targetnode.x + targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p3 = { x: targetnode.x, y: targetnode.y - targetnode.ry};
				var line1 = { P1: p1, P2: p2};//left to right  [Math.PI/6, Math.PI*5/6]
				var line2 = { P1: p3, P2: p2};//up to right [Math.PI*3/2, Math.PI*2] or [0, Math.PI *1/6]
				var line3 = { P1: p1, P2: p3};//left to up   [ Math.PI * 5/6, Math.PI *3/2]
				// EQ: y = x1 + (y2-y1)/(x2-x1) * (x-x1)  => (y2-y1)/(x2-x1) *x - y - (y2-y1)/(x2-x1) * x1 + x1 = 0 
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				if(_theta%(Math.PI/2) === 0) {//to handle the special condition PI/2 for tan()
					var EQline_theta = {A:1, B: 0 , C: -targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI/6 & _theta <=  Math.PI*5/6){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	// console.log("line1");console.log(slope1);											
				} else if ( (_theta >= Math.PI*3/2 & _theta <= Math.PI*2 )||(_theta >= 0 & _theta <= Math.PI *1/6 )){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if (_theta >= Math.PI * 5/6 & _theta <= Math.PI *3/2) {
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
																		//console.log("node");console.log(targetnode.x +" "+ targetnode.y);
																		//console.log("interP");console.log(interP);
																		//console.log("current_r "+ current_r);
		}
			break;
		case "diamond":{		
				var p1 = { x: targetnode.x - targetnode.rx, y: targetnode.y };//left point
				var p2 = { x: targetnode.x,        y: targetnode.y - targetnode.ry }; //up point
				var p3 = { x: targetnode.x + targetnode.rx, y: targetnode.y };// right point
				var p4 = { x: targetnode.x,        y: targetnode.y + targetnode.ry};//down point
				var line1 = {P1:p1, P2:p2}; //left to up [Math.PI,Math.PI*3/2 ]
				var line2 = {P1:p2, P2:p3}; // up to right [Math.PI*3/2, Math.PI*2]
				var line3 = {P1:p4, P2:p3}; // down to right  [0, Math.PI *1/2]
				var line4 = {P1:p1, P2:p4}; // left to down [ Math.PI*1/2, Math.PI*2/2]
				
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);
				var slope4 = (line4.P2.y -line4.P1.y)/(line4.P2.x -line4.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				var EQline4 = {A:slope4, B: -1, C: line4.P1.y - slope4 * line4.P1.x};
				//var slope_theta = Math.tan((_theta)%(Math.PI/2)); 
				//var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				if(_theta%(Math.PI/2) === 0) {//to handle the special condition PI/2 for tan()
					var EQline_theta = {A:1, B: 0 , C: -targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI & _theta <=Math.PI*3/2){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if(_theta>= Math.PI*3/2 & _theta<= Math.PI*2){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= 0 & _theta<= Math.PI *1/2){
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*1/2 & _theta<= Math.PI*2/2){
					interP = interP_2lines(EQline4.A, EQline4.B,EQline4.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
		}
			break;
		case "hexagon":{
				var p1 = { x: targetnode.x - targetnode.rx,		y: targetnode.y };//left
				var p2 = { x: targetnode.x - targetnode.rx /2,	y: targetnode.y - targetnode.ry * Math.sqrt(3)/2}; //left-top
				var p3 = { x: targetnode.x + targetnode.rx /2,	y: targetnode.y - targetnode.ry * Math.sqrt(3)/2}; // right-top
				var p4 = { x: targetnode.x + targetnode.rx,       y: targetnode.y };//right
				var p5 = { x: targetnode.x + targetnode.rx /2,	y: targetnode.y + targetnode.ry * Math.sqrt(3)/2};//right-bottom
				var p6 = { x: targetnode.x - targetnode.rx /2,	y: targetnode.y +targetnode.ry * Math.sqrt(3)/2};//left-bottom
				var line1 = {P1: p1, P2:p2};// [Math.PI*3/3， Math.PI*4/3]
				var line2 = {P1: p2, P2:p3};// [Math.PI*4/3，Math.PI*5/3]
				var line3 = {P1: p3, P2:p4}; // [Math.PI*5/3，Math.PI*6/3]
				var line4 = {P1: p5, P2:p4};//[0, Math.PI * 1/3]
				var line5 = {P1: p6, P2:p5};//[Math.PI*1/3,  Math.PI * 2/3]
				var line6 = {P1: p1, P2:p6};//[Math.PI*2/3, Math.PI*3/3]
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);
				var slope4 = (line4.P2.y -line4.P1.y)/(line4.P2.x -line4.P1.x);	
				var slope5 = (line5.P2.y -line5.P1.y)/(line5.P2.x -line5.P1.x);
				var slope6 = (line6.P2.y -line6.P1.y)/(line6.P2.x -line6.P1.x);				
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				var EQline4 = {A:slope4, B: -1, C: line4.P1.y - slope4 * line4.P1.x};
				var EQline5 = {A:slope5, B: -1, C: line5.P1.y - slope5 * line5.P1.x};
				var EQline6 = {A:slope6, B: -1, C: line6.P1.y - slope6 * line6.P1.x};
				//var slope_theta = Math.tan((_theta)%(Math.PI/2)); 
				//var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				if(_theta%(Math.PI/2) === 0) {//to handle the special condition PI/2 for tan()
					var EQline_theta = {A:1, B: 0 , C: -targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta>= Math.PI*3/3 & _theta<= Math.PI*4/3){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if(_theta>= Math.PI*4/3 & _theta<= Math.PI*5/3){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*5/3 & _theta<= Math.PI*6/3){
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= 0 & _theta<= Math.PI * 1/3){
					interP = interP_2lines(EQline4.A, EQline4.B,EQline4.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*1/3 & _theta<= Math.PI * 2/3){
					interP = interP_2lines(EQline5.A, EQline5.B,EQline5.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta >= Math.PI*2/3 & _theta <= Math.PI*3/3){
					interP = interP_2lines(EQline6.A, EQline6.B,EQline6.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
			
		}
			break;
		default:;	
	}
	newr = current_r - default_RADIUSH * newr_DISCOUNT;	//set the newcx and newcy according to current_r	
	var newcx = targetnode.x + newr * Math.cos(_theta);
	var newcy = targetnode.y + newr * Math.sin(_theta);
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	// end of use inner same figure bound as the track
	
	var handleP = { x:(P0.x * 1/8) + 3* P1.x * 1/8 +3 * P2.x * 1/8 + P3.x * 1/8,  y:(P0.y * 1/8) + 3* P1.y * 1/8 +3 * P2.y * 1/8 + P3.y * 1/8	};	
	
	var templine = "M"+ P0.x + " " + P0.y + " " + "C" + P1.x+" " + P1.y + " " + P2.x+" " + P2.y +" "+ P3.x+" " + P3.y;
	var templabel = generate_label(targetnode, targetnode, _arrowType,3);
	var targetnodeP = {x: targetnode.x, y: targetnode.y};
	var templabelP = cal_labelP(handleP,targetnodeP, targetnodeP, 3);
	var tempbcurve3p={ 
		id:"edge"+String(Edgecurrent_IdNUM),
		power:3,
		nodeid: _nodeid,
		startid:_nodeid,
		endid:_nodeid,
		theta: _theta,
		handleP: handleP,
		P0: P0,
		P1: P1,
		P2: P2,
		P3: P3,
		line: templine,	
		type: _arrowType,
		dotted: 0, //dotted or real line
		color: defaultCOLOR,
		strokewidth:default_strokeWIDTH,
		label: templabel,
		labelP: templabelP,
		labelFsize: defaultFONTSIZE,
		labelInitial:true,
		labelshow: true,
		curve_LR:selfcurve_LR,
		handlePshow: false,		
		handleInitial: true,
		IsAutoGenerated: false,
		selected:false
	};
	return tempbcurve3p;
}

//函数：根据给定节点生成一条路径曲线  power 2 and power 3
function generate_edge(_nodes,_startid, _endid, _arrowType){ //generate by setting the nodes' ids
	var tempedge = null;
	if (_startid === _endid){
		var _nodeid = _startid;
		tempedge = generate_bcurve3p(_nodes,_nodeid, _arrowType);
	} else {
		tempedge = generate_bcurve2p(_nodes,_startid,_endid, _arrowType);
	}
	return tempedge;
}

//函数：根据参数来更新对应的某B曲线数据 power 2
function update_bcurve2p(_nodes,_bcurve2p){
			var _i = matchnodeindex(_nodes,_bcurve2p.startid);
			var _j = matchnodeindex(_nodes,_bcurve2p.endid);
			var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
			var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
			var _handleP = _bcurve2p.handleP;
			var _handleInitial = _bcurve2p.handleInitial;
			/*if (_handleInitial){
				_handleP = { x:(_startP.x + _endP.x)/2,  y:(_startP.y + _endP.y)/2	};  //set it as the middle point between startP and endP 
			} */
			var tempcP = {x: _handleP.x * 2 - (_startP.x + _endP.x) / 2, y: _handleP.y * 2 - (_startP.y + _endP.y) / 2};
			var templine = "M"+ _startP.x + " " + _startP.y + " " + "Q" + tempcP.x+" " + tempcP.y + " " + _endP.x+" " + _endP.y ;
			var templableP = cal_labelP(_handleP, _startP, _endP, 2);
			var tempbcurve2p={
				id:_bcurve2p.id,
				power:2,
				startid: _bcurve2p.startid,
				endid: _bcurve2p.endid,
				handleP:_handleP,//updated
				cP:tempcP,//updated
				line: templine,//updated
				type: _bcurve2p.type,
				dotted: _bcurve2p.dotted,
				color:_bcurve2p.color,
				strokewidth:_bcurve2p.strokewidth,
				label: _bcurve2p.label,
				labelP: templableP,//updated
				labelFsize: _bcurve2p.labelFsize,
				labelInitial:_bcurve2p.labelInitial,
				labelshow: _bcurve2p.labelshow,
				handlePshow: _bcurve2p.handlePshow,
				handleInitial:_handleInitial,
				curve_LR:_bcurve2p.curve_LR,
				IsAutoGenerated: _bcurve2p.IsAutoGenerated,
				selected:_bcurve2p.selected
			};
		return tempbcurve2p;
}

//函数：根据新的夹角更新对应的某B曲线 power3
function update_bcurve3p(_nodes,_bcurve3p, _theta, _Angle){
	var nodeid =_bcurve3p.nodeid;
	var i = matchnodeindex(_nodes,nodeid);
	var targetnode=_nodes[i];
	var selfcurve_LR= _bcurve3p.curve_LR;
	//use another idea: inner same figure bound as the track
	var current_r=0;
	var newr=0;
	switch(targetnode.type){
		case "ellipse": {
			//var current_P = {x: targetnode.x + targetnode.rx * Math.cos(_theta),y: targetnode.y + targetnode.ry * Math.sin(_theta)};
			//current_r =  Math.sqrt((current_P.x - targetnode.x)*(current_P.x - targetnode.x)  
			//						+ (current_P.y - targetnode.y)*(current_P.y - targetnode.y));
						var aa=targetnode.rx;
			var bb=targetnode.ry;
			current_r = aa * bb / Math.sqrt( (bb * Math.cos(_theta) ) * (bb * Math.cos(_theta) ) +  (aa * Math.sin(_theta)) *(aa * Math.sin(_theta)) )
		}
			break;
		case "rect":{
			var current_r = 0;
			//var p1 = {x:_node.x - _node.rx, y: _node.y - _node.ry};
			//var p2 = {x:_node.x + _node.rx, y: _node.y - _node.ry};
			//var p3 = {x:_node.x + _node.rx, y: _node.y + _node.ry};
			//var p4 = {x:_node.x - _node.rx, y: _node.y + _node.ry};
			//var line1 = {P1: p1, P2:p2};//rectalpha interval [rectalpha, Math.PI-rectalpha]
			//var line2 = {P1: p2, P2:p3};//[2* Math.PI - rectalpha, 2* Math.PI] & [0, rectalpha] 										
			//var line3 = {P1: p4, P2:p3};//[Math.PI+ rectalpha, 2* Math.PI - rectalpha]										
			//var line4 = {P1: p1, P2:p4};//[Math.PI- rectalpha, Math.PI + rectalpha]			
			var rectalpha = Math.atan(targetnode.ry / targetnode.rx); 
			//console.log("rectalpha");console.log(rectalpha);
			//console.log("_theta");console.log(_theta);
			//console.log("Math.PI" + Math.PI);
			if (_theta >= rectalpha & _theta <= Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );//console.log("_theta >= rectalpha & _theta <= Math.PI - rectalpha");
			} else if ( (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) || (_theta >= 0 & _theta<= rectalpha)){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );// console.log("if (_theta >= 2* Math.PI - rectalpha & _theta <= 2* Math.PI) | (_theta >= 0 <= rectalpha)");
			} else if (_theta >= Math.PI+ rectalpha & _theta <= 2* Math.PI - rectalpha){
				current_r = Math.abs( targetnode.ry / Math.sin(_theta) );
			} else if (_theta >= Math.PI- rectalpha & _theta <= Math.PI + rectalpha){
				current_r = Math.abs( targetnode.rx/ Math.cos(_theta) );
			}
		} 
			break;
		case "triangle":{		
				var p1 = { x: targetnode.x - targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p2 = { x: targetnode.x + targetnode.rx*Math.sqrt(3)/2, y: targetnode.y + targetnode.rx/2 };
				var p3 = { x: targetnode.x, y: targetnode.y - targetnode.ry};
				var line1 = { P1: p1, P2: p2};//left to right  [Math.PI/6, Math.PI*5/6]
				var line2 = { P1: p3, P2: p2};//up to right [Math.PI*3/2, Math.PI*2] or [0, Math.PI *1/6]
				var line3 = { P1: p1, P2: p3};//left to up   [ Math.PI * 5/6, Math.PI *3/2]
				// EQ: y = x1 + (y2-y1)/(x2-x1) * (x-x1)  => (y2-y1)/(x2-x1) *x - y - (y2-y1)/(x2-x1) * x1 + x1 = 0 
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				if(_theta%(Math.PI/2) === 0) {
					var EQline_theta = {A:1, B: 0 , C: targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI/6 & _theta <=  Math.PI*5/6){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	//console.log("line1");console.log(slope1);											
				} else if ( (_theta >= Math.PI*3/2 & _theta <= Math.PI*2 )||(_theta >= 0 & _theta <= Math.PI *1/6 )){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if (_theta >= Math.PI * 5/6 & _theta <= Math.PI *3/2) {
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
																		//console.log("node");console.log(targetnode.x +" "+ targetnode.y);
																		//console.log("interP");console.log(interP);
																		//console.log("current_r "+ current_r);
		}
			break;
		case "diamond":{		
				var p1 = { x: targetnode.x - targetnode.rx, y: targetnode.y };//left point
				var p2 = { x: targetnode.x,        y: targetnode.y - targetnode.ry }; //up point
				var p3 = { x: targetnode.x + targetnode.rx, y: targetnode.y };// right point
				var p4 = { x: targetnode.x,        y: targetnode.y + targetnode.ry};//down point
				var line1 = {P1:p1, P2:p2}; //left to up [Math.PI,Math.PI*3/2 ]
				var line2 = {P1:p2, P2:p3}; // up to right [Math.PI*3/2, Math.PI*2]
				var line3 = {P1:p4, P2:p3}; // down to right  [0, Math.PI *1/2]
				var line4 = {P1:p1, P2:p4}; // left to down [ Math.PI*1/2, Math.PI*2/2]
				
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);
				var slope4 = (line4.P2.y -line4.P1.y)/(line4.P2.x -line4.P1.x);					
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				var EQline4 = {A:slope4, B: -1, C: line4.P1.y - slope4 * line4.P1.x};
				if(_theta%(Math.PI/2) === 0) {
					var EQline_theta = {A:1, B: 0 , C: targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				var interP = {};
				if(_theta >= Math.PI & _theta <=Math.PI*3/2){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if(_theta>= Math.PI*3/2 & _theta<= Math.PI*2){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= 0 & _theta<= Math.PI *1/2){
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*1/2 & _theta<= Math.PI*2/2){
					interP = interP_2lines(EQline4.A, EQline4.B,EQline4.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
		}
			break;
		case "hexagon":{
				var p1 = { x: targetnode.x - targetnode.rx,		y: targetnode.y };//left
				var p2 = { x: targetnode.x - targetnode.rx /2,	y: targetnode.y - targetnode.ry * Math.sqrt(3)/2}; //left-top
				var p3 = { x: targetnode.x + targetnode.rx /2,	y: targetnode.y - targetnode.ry * Math.sqrt(3)/2}; // right-top
				var p4 = { x: targetnode.x + targetnode.rx,       y: targetnode.y };//right
				var p5 = { x: targetnode.x + targetnode.rx /2,	y: targetnode.y + targetnode.ry * Math.sqrt(3)/2};//right-bottom
				var p6 = { x: targetnode.x - targetnode.rx /2,	y: targetnode.y +targetnode.ry * Math.sqrt(3)/2};//left-bottom
				var line1 = {P1: p1, P2:p2};// [Math.PI*3/3， Math.PI*4/3]
				var line2 = {P1: p2, P2:p3};// [Math.PI*4/3，Math.PI*5/3]
				var line3 = {P1: p3, P2:p4}; // [Math.PI*5/3，Math.PI*6/3]
				var line4 = {P1: p5, P2:p4};//[0, Math.PI * 1/3]
				var line5 = {P1: p6, P2:p5};//[Math.PI*1/3,  Math.PI * 2/3]
				var line6 = {P1: p1, P2:p6};//[Math.PI*2/3, Math.PI*3/3]
				var slope1 = (line1.P2.y -line1.P1.y)/(line1.P2.x -line1.P1.x);
				var slope2 = (line2.P2.y -line2.P1.y)/(line2.P2.x -line2.P1.x);	
				var slope3 = (line3.P2.y -line3.P1.y)/(line3.P2.x -line3.P1.x);
				var slope4 = (line4.P2.y -line4.P1.y)/(line4.P2.x -line4.P1.x);	
				var slope5 = (line5.P2.y -line5.P1.y)/(line5.P2.x -line5.P1.x);
				var slope6 = (line6.P2.y -line6.P1.y)/(line6.P2.x -line6.P1.x);				
				var EQline1 = {A:slope1, B: -1, C: line1.P1.y - slope1 * line1.P1.x};
				var EQline2 = {A:slope2, B: -1, C: line2.P1.y - slope2 * line2.P1.x};
				var EQline3 = {A:slope3, B: -1, C: line3.P1.y - slope3 * line3.P1.x};
				var EQline4 = {A:slope4, B: -1, C: line4.P1.y - slope4 * line4.P1.x};
				var EQline5 = {A:slope5, B: -1, C: line5.P1.y - slope5 * line5.P1.x};
				var EQline6 = {A:slope6, B: -1, C: line6.P1.y - slope6 * line6.P1.x};
				if(_theta%(Math.PI/2) === 0) {
					var EQline_theta = {A:1, B: 0 , C: targetnode.x};
				} else {
					var slope_theta = Math.tan(_theta); //console.log("tan(_theta) "+Math.tan(_theta) );
					var EQline_theta = {A:slope_theta, B: -1 , C: targetnode.y - slope_theta * targetnode.x};
				}
				
				var interP = {};
				if(_theta>= Math.PI*3/3 & _theta<= Math.PI*4/3){
					interP = interP_2lines(EQline1.A, EQline1.B,EQline1.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);						
				} else if(_theta>= Math.PI*4/3 & _theta<= Math.PI*5/3){
					interP = interP_2lines(EQline2.A, EQline2.B,EQline2.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*5/3 & _theta<= Math.PI*6/3){
					interP = interP_2lines(EQline3.A, EQline3.B,EQline3.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= 0 & _theta<= Math.PI * 1/3){
					interP = interP_2lines(EQline4.A, EQline4.B,EQline4.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta>= Math.PI*1/3 & _theta<= Math.PI * 2/3){
					interP = interP_2lines(EQline5.A, EQline5.B,EQline5.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				} else if(_theta >= Math.PI*2/3 & _theta <= Math.PI*3/3){
					interP = interP_2lines(EQline6.A, EQline6.B,EQline6.C, EQline_theta.A, EQline_theta.B, EQline_theta.C);	
				}
				if (interP.numsolution ===1) current_r = Math.sqrt( (interP.interP.x - targetnode.x) *(interP.interP.x - targetnode.x)
																		+ (interP.interP.y - targetnode.y)*(interP.interP.y - targetnode.y));
			
		}
			break;
		default:;	
	}
	newr = current_r - default_RADIUSH * newr_DISCOUNT;	//set the newcx and newcy according to current_r	
	var newcx = targetnode.x + newr * Math.cos(_theta);
	var newcy = targetnode.y + newr * Math.sin(_theta);
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	// end of use inner same figure bound as the track
	
	var P0 = {x: newcx , y: newcy };
	var P3 = P0;
	var P1 = {x: newcx + selfcurve_LR * Math.cos(_theta + _Angle), y: newcy + selfcurve_LR * Math.sin(_theta + _Angle)};
	var P2 = {x: newcx + selfcurve_LR * Math.cos(_theta - _Angle), y: newcy + selfcurve_LR * Math.sin(_theta - _Angle)};
	
	var handleP = { x:(P0.x * 1/8) + 3* P1.x * 1/8 +3 * P2.x * 1/8 + P3.x * 1/8,  y:(P0.y * 1/8) + 3* P1.y * 1/8 +3 * P2.y * 1/8 + P3.y * 1/8	};	//取中点为控制点
	var templine = "M"+ P0.x + " " + P0.y + " " + "C" + P1.x+" " + P1.y + " " + P2.x+" " + P2.y +" "+ P3.x+" " + P3.y;
	var templabel= "a"+ i +"_"+ i;
	var targetnodeP = {x: targetnode.x, y: targetnode.y};
	var templabelP = cal_labelP(handleP, targetnodeP, targetnodeP, 3);
	var tempbcurve3p={ 
		id:_bcurve3p.id,
		power:3,
		nodeid: nodeid,
		startid: nodeid,
		endid: nodeid,
		theta: _theta,
		handleP: handleP,//updated
		P0: P0,
		P1: P1,//updated
		P2: P2,//updated
		P3: P3,
		line: templine,//updated		
		type: _bcurve3p.type,
		dotted: _bcurve3p.dotted, //dotted or real line
		color:_bcurve3p.color,
		strokewidth:_bcurve3p.strokewidth,
		label: _bcurve3p.label,
		labelP: templabelP,//updated
		labelFsize: _bcurve3p.labelFsize,
		labelInitial:_bcurve3p.labelInitial,
		labelshow: _bcurve3p.labelshow,
		curve_LR: _bcurve3p.curve_LR,
		handlePshow: _bcurve3p.handlePshow,
		handleInitial: _bcurve3p.handleInitial,
		IsAutoGenerated: _bcurve3p.IsAutoGenerated,
		selected:false
	};	
	return tempbcurve3p;
}

//函数：节点数据或handleP更新后更新对应的某B曲线 power 2 and power 3
function update_bcurve(_nodes,_bcurve){
	var tempedge = null;
	//var _startindex=matchnodeindex(nodes,_bcurve.startid);
	//var _endindex=matchnodeindex(nodes,_bcurve.endid);
	//var currentbcurveindex=lookfor_duplicatedbcurve(nodes,edges,_starindex,_endindex,_bcurve.type);//find the bcurve index
	//if (currentbcurveindex>=0 & currentbcurveindex < edges.length) {alert("found duplicated!");} else {return tempedge;}
	if(_bcurve.power ===2){
		var tempbcurve2p = update_bcurve2p(_nodes,_bcurve);// update because the node position changed or the handleP changed		
		tempedge = tempbcurve2p;
	}else if (_bcurve.power ===3){	
		var nodeid =_bcurve.nodeid;
		var i = matchnodeindex(_nodes,nodeid);
		var targetnode=_nodes[i];
		var nodeP = {x: targetnode.x, y: targetnode.y};
		var handleP = _bcurve.handleP; //console.log("handleP:");console.log(handleP);
		var newtheta = 0;			
		newtheta = calculate_theta(nodeP, handleP);	// calculate the new theta with the new handleP		
		//console.log(newtheta);
		var tempbcurve3p =  update_bcurve3p(_nodes,_bcurve, newtheta, selfpathANGLE_default);	//update because the node pos changed or the handleP pos(theta) changed		
		tempedge = tempbcurve3p;
	}
	
	return tempedge;
}

//函数：节点数据更新后更新B曲线数据 power 2 and power 3
function update_edges(_nodes,_edges){
	var temp=[];
	for (var i=0; i< _edges.length; i++){
		temp.push(update_bcurve(_nodes,_edges[i]));
	}
	return temp;
}

//函数：查找相同的路径  power 2 and power 3
function lookfor_duplicatedbcurve(_nodes,_edges,_startid,_endid,_type){ // decide if the curve exists with given startid and endid

	var found_bcurve_index = -1;
	//console.log(_startid);	console.log(_endid);	console.log(_type);
	for (var i =0; i< _edges.length; i++) {	
		//console.log(_edges[i]);
		if (_edges[i].power ===3) {
			if (_edges[i].nodeid === _startid & _edges[i].nodeid === _endid & _edges[i].type ===_type) {
				found_bcurve_index = i;				
				return found_bcurve_index;
			}
		} else if (_edges[i].power ===2){
			switch(_type){
				case "bi":
					{	
							if (_edges[i].startid === _startid & _edges[i].endid === _endid & _edges[i].type === _type){
									found_bcurve_index = i;
									return found_bcurve_index;
							}
							if (_edges[i].startid === _endid & _edges[i].endid === _startid & _edges[i].type === _type){
									found_bcurve_index = i;
									return found_bcurve_index;
							}
					}
					break;
				case "uni":
					{						
						if (_edges[i].startid === _startid & _edges[i].endid === _endid & _edges[i].type === _type){
							found_bcurve_index = i;
							return found_bcurve_index;
						}
					}
					break;
				default: ;
			} // end of switch
		}//end if power ===2 
	} // end of for loop
	//console.log("notduplicated!");
	return found_bcurve_index;
}

//函数：查找被由椭圆矩形六边形出发的单向箭头指向的节点 
function Is_dependentnode(_node,_nodes,_edges){
	var Is_dependentnode = false;
	for(var i=0; i<_edges.length;i++){
		if (_edges[i].power === 2 & _edges[i].type === "uni"){
			var startnode = _nodes[matchnodeindex(_nodes,_edges[i].startid)];
			var endnode = _nodes[matchnodeindex(_nodes,_edges[i].endid)];
			if  (_node.id === endnode.id & (startnode.type === "rect" || startnode.type === "ellipse" || startnode.type === "hexagon") ) Is_dependentnode = true;			
		}
	}
	return Is_dependentnode;
}

//函数： 寻找bcurve与其中一端节点的交点 power 2
function lookup_interP_with_oneNode_bcurve2p(_nodes, _bcurve2p, _witchnode){

	if (_witchnode==="startP"){
		var startt=0;
		var endt=1;
		var stept= 1/Nt;
		var stopt = 2;
		var _node= _nodes[matchnodeindex( _nodes, _bcurve2p.startid)];
	} else if (_witchnode ==="endP") {
		var startt=1;
		var endt=0;
		var stept= (-1) * 1/Nt;
		var stopt =-1;
		var _node= _nodes[matchnodeindex( _nodes, _bcurve2p.endid)];
	}

	var interP = {x: _node.x+ _node.rx, y: _node.y+ _node.ry};
	var inter_t = startt+0.001;
	var interP_out = {x: _node.x+60, y: _node.y+60};
	var inter_t_out = startt+0.002;
	var Isfound = false;
	
	var _startP= _nodes[ matchnodeindex(_nodes, _bcurve2p.startid)];
	var _endP = _nodes[ matchnodeindex(_nodes, _bcurve2p.endid)];
	var _cP = _bcurve2p.cP;	
	
	switch (_node.type){
		case "ellipse": 
			{
				var aa = _node.rx; //console.log(aa);
				var bb = _node.ry; //console.log(bb);
				//var cc = Math.sqrt(aa*aa - bb*bb );
				var centerP = {x: _node.x, y: _node.y};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= centerP.x - aa || tP.x >= centerP.x + aa  || tP.y <= centerP.y - bb  || tP.y >= centerP.y + bb ){
						out_of_circumference=true;
					} else if ( ( ( tP.x - centerP.x) * (tP.x - centerP.x) / (aa * aa) +  (tP.y - centerP.y) * (tP.y - centerP.y) / (bb * bb) ) >= 1 ) {
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "rect": 
			{	
				var p1 = {x:_node.x - _node.rx, y: _node.y - _node.ry};
				var p2 = {x:_node.x + _node.rx, y: _node.y - _node.ry};
				var p3 = {x:_node.x + _node.rx, y: _node.y + _node.ry};
				var p4 = {x:_node.x - _node.rx, y: _node.y + _node.ry};
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3}; 										
				var line3 = {P1: p4, P2:p3};										
				var line4 = {P1: p1, P2:p4};
				
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry  || tP.y >= _node.y + _node.ry ){
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "triangle":
			{			
				var p1 = { x: _node.x - _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p2 = { x: _node.x + _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p3 = { x: _node.x, y: _node.y - _node.ry};
				var line1 = { P1: p1, P2: p2};//left to right
				var line2 = { P1: p3, P2: p2};//up to right
				var line3 = { P1: p1, P2: p3};// left to up
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx*Math.sqrt(3)/2 || tP.x >= _node.x + _node.rx*Math.sqrt(3)/2  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.rx/2 ){
						out_of_circumference=true;
					} else {
						var tri_y;
						var a2 = line2.P1.y;//intercept
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						if (tP.x <= _node.x) {
							tri_y = a3 +  b3 * (tP.x - line3.P1.x);
						} else {
							tri_y = a2 +  b2 * (tP.x - line2.P1.x);
						}
							if (tP.y <= tri_y ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "diamond": 
			{
				var p1 = { x: _node.x - _node.rx, y: _node.y };//left point
				var p2 = { x: _node.x,        y: _node.y - _node.ry }; //up point
				var p3 = { x: _node.x + _node.rx, y: _node.y };// right point
				var p4 = { x: _node.x,        y: _node.y + _node.ry};//down point
				var line1 = {P1:p1, P2:p2}; //left to up
				var line2 = {P1:p2, P2:p3}; // up to right
				var line3 = {P1:p4, P2:p3}; // down to right 
				var line4 = {P1:p1, P2:p4}; // left to down
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.ry ){
						out_of_circumference=true;
					} else {
						var diamond_y1;
						var diamond_y2;
						var a1 = line1.P1.y;//intercept
						var b1 = (line1.P2.y - line1.P1.y)/(line1.P2.x - line1.P1.x);//slope
						var a2 = line2.P1.y;//intercept
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						var a4 = line4.P1.y;//intercept
						var b4 = (line4.P2.y - line4.P1.y)/(line4.P2.x - line4.P1.x);//slope
						if (tP.x <= _node.x) {
							diamond_y1 = a1 +  b1 * (tP.x - line1.P1.x);
							diamond_y2 = a4 +  b4 * (tP.x - line4.P1.x);
						} else {
							diamond_y1 = a2 +  b2 * (tP.x - line2.P1.x);
							diamond_y2 = a3 +  b3 * (tP.x - line3.P1.x);
						}
						if (tP.y <= diamond_y1 || tP.y >= diamond_y2 ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "hexagon":
			{
				var p1 = { x: _node.x - _node.rx,		y: _node.y };//left
				var p2 = { x: _node.x - _node.rx /2,	y: _node.y - _node.ry * Math.sqrt(3)/2}; //left-top
				var p3 = { x: _node.x + _node.rx /2,	y: _node.y - _node.ry * Math.sqrt(3)/2}; // right-top
				var p4 = { x: _node.x + _node.rx,       y: _node.y };//right
				var p5 = { x: _node.x + _node.rx /2,	y: _node.y + _node.ry * Math.sqrt(3)/2};//right-bottom
				var p6 = { x: _node.x - _node.rx /2,	y: _node.y +_node.ry * Math.sqrt(3)/2};//left-bottom
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3};
				var line3 = {P1: p3, P2:p4};
				var line4 = {P1: p5, P2:p4};
				var line5 = {P1: p6, P2:p5};
				var line6 = {P1: p1, P2:p6};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*_startP.x + 2*t*(1-t)*_cP.x + t*t*_endP.x ;
					var ty = (1-t)*(1-t)*_startP.y + 2*t*(1-t)*_cP.y + t*t*_endP.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.ry ){
						out_of_circumference=true;
					} else {
						var hexagon_y1;
						var hexagon_y2;
						var a1 = line1.P1.y;//intercept
						var b1 = (line1.P2.y - line1.P1.y)/(line1.P2.x - line1.P1.x);//slope
						var a6 = line6.P1.y;//intercept
						var b6 = (line6.P2.y - line6.P1.y)/(line6.P2.x - line6.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						var a4 = line4.P1.y;//intercept
						var b4 = (line4.P2.y - line4.P1.y)/(line4.P2.x - line4.P1.x);//slope
						if (tP.x <= _node.x - _node.rx/2) {
							hexagon_y1 = a1 +  b1 * (tP.x - line1.P1.x);
							hexagon_y2 = a6 +  b6 * (tP.x - line6.P1.x);
						} else if (tP.x >= _node.x + _node.rx/2){
							hexagon_y1 = a3 +  b3 * (tP.x - line3.P1.x);
							hexagon_y2 = a4 +  b4 * (tP.x - line4.P1.x);
						} else { 
							hexagon_y1=line2.P1.y;
							hexagon_y2 =line5.P1.y;
						}
							if (tP.y <= hexagon_y1 || tP.y >= hexagon_y2 ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*_startP.x + 2*inter_t_out*(1-inter_t_out)*_cP.x + inter_t_out*inter_t_out*_endP.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*_startP.y + 2*inter_t_out*(1-inter_t_out)*_cP.y + inter_t_out*inter_t_out*_endP.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		default:	;
	}// end of switch (_node.type)
	var temp = {Isfound: Isfound, interP: interP, inter_t: inter_t, interP_out: interP_out, inter_t_out: inter_t_out};
	return temp;
}

//函数： 寻找bcurve3p与其中一端节点的交点与其中一端节点的交点  power 3
function lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p, _witchnode){

	if (_witchnode==="startP"){
		var startt=0;
		var endt=1;
		var stept= 1/Nt;
		var stopt = 2;
		
	} else if (_witchnode ==="endP") {
		var startt=1;
		var endt=0;
		var stept= (-1) * 1/Nt;
		var stopt =-1;
	}
	var _node= _nodes[matchnodeindex( _nodes, _bcurve3p.nodeid)];
	var interP = {x: _node.x+ _node.rx, y: _node.y+ _node.ry};//初始化，一旦找不到合适的点，则以此default点为箭头的位置
	var inter_t = startt+0.001;
	var interP_out = {x: _node.x+60, y: _node.y+60};
	var inter_t_out = startt+0.002;
	var Isfound = false;
	
	var _P0 = _bcurve3p.P0;
	var _P1 = _bcurve3p.P1;
	var _P2 = _bcurve3p.P2;	
	var _P3 = _bcurve3p.P3;	
	
	switch (_node.type){
		case "ellipse": 
			{
				var aa = _node.rx; //console.log(aa);
				var bb = _node.ry; //console.log(bb);
				//var cc = Math.sqrt(aa*aa - bb*bb );
				var centerP = {x: _node.x, y: _node.y};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= centerP.x - aa || tP.x >= centerP.x + aa  || tP.y <= centerP.y - bb  || tP.y >= centerP.y + bb ){
						out_of_circumference=true;
					} else if ( ( ( tP.x - centerP.x) * (tP.x - centerP.x) / (aa * aa) +  (tP.y - centerP.y) * (tP.y - centerP.y) / (bb * bb) ) >= 1 ) {
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "rect": 
			{	
				var p1 = {x:_node.x - _node.rx, y: _node.y - _node.ry};
				var p2 = {x:_node.x + _node.rx, y: _node.y - _node.ry};
				var p3 = {x:_node.x + _node.rx, y: _node.y + _node.ry};
				var p4 = {x:_node.x - _node.rx, y: _node.y + _node.ry};
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3}; 										
				var line3 = {P1: p4, P2:p3};										
				var line4 = {P1: p1, P2:p4};
				
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry  || tP.y >= _node.y + _node.ry ){
						out_of_circumference=true;
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "triangle":
			{			
				var p1 = { x: _node.x - _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p2 = { x: _node.x + _node.rx*Math.sqrt(3)/2, y: _node.y+_node.rx/2 };
				var p3 = { x: _node.x, y: _node.y - _node.ry};
				var line1 = { P1: p1, P2: p2};//left to right
				var line2 = { P1: p3, P2: p2};//up to right
				var line3 = { P1: p1, P2: p3};// left to up
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx*Math.sqrt(3)/2 || tP.x >= _node.x + _node.rx*Math.sqrt(3)/2  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.rx/2 ){
						out_of_circumference=true;
					} else {
						var tri_y;
						var a2 = line2.P1.y;//intercept
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						if (tP.x <= _node.x) {
							tri_y = a3 +  b3 * (tP.x - line3.P1.x);
						} else {
							tri_y = a2 +  b2 * (tP.x - line2.P1.x);
						}
							if (tP.y <= tri_y ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;
						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "diamond": 
			{
				var p1 = { x: _node.x - _node.rx, y: _node.y };//left point
				var p2 = { x: _node.x,        y: _node.y - _node.ry }; //up point
				var p3 = { x: _node.x + _node.rx, y: _node.y };// right point
				var p4 = { x: _node.x,        y: _node.y + _node.ry};//down point
				var line1 = {P1:p1, P2:p2}; //left to up
				var line2 = {P1:p2, P2:p3}; // up to right
				var line3 = {P1:p4, P2:p3}; // down to right 
				var line4 = {P1:p1, P2:p4}; // left to down
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.ry ){
						out_of_circumference=true;
					} else {
						var diamond_y1;
						var diamond_y2;
						var a1 = line1.P1.y;//intercept
						var b1 = (line1.P2.y - line1.P1.y)/(line1.P2.x - line1.P1.x);//slope
						var a2 = line2.P1.y;//intercept
						var b2 = (line2.P2.y - line2.P1.y)/(line2.P2.x - line2.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						var a4 = line4.P1.y;//intercept
						var b4 = (line4.P2.y - line4.P1.y)/(line4.P2.x - line4.P1.x);//slope
						if (tP.x <= _node.x) {
							diamond_y1 = a1 +  b1 * (tP.x - line1.P1.x);
							diamond_y2 = a4 +  b4 * (tP.x - line4.P1.x);
						} else {
							diamond_y1 = a2 +  b2 * (tP.x - line2.P1.x);
							diamond_y2 = a3 +  b3 * (tP.x - line3.P1.x);
						}
							if (tP.y <= diamond_y1 || tP.y >= diamond_y2 ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;

						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		case "hexagon":
			{
				var p1 = { x: _node.x - _node.rx,		y: _node.y };//left
				var p2 = { x: _node.x - _node.rx /2,	y: _node.y - _node.ry * Math.sqrt(3)/2}; //left-top
				var p3 = { x: _node.x + _node.rx /2,	y: _node.y - _node.ry * Math.sqrt(3)/2}; // right-top
				var p4 = { x: _node.x + _node.rx,       y: _node.y };//right
				var p5 = { x: _node.x + _node.rx /2,	y: _node.y + _node.ry * Math.sqrt(3)/2};//right-bottom
				var p6 = { x: _node.x - _node.rx /2,	y: _node.y +_node.ry * Math.sqrt(3)/2};//left-bottom
				var line1 = {P1: p1, P2:p2};
				var line2 = {P1: p2, P2:p3};
				var line3 = {P1: p3, P2:p4};
				var line4 = {P1: p5, P2:p4};
				var line5 = {P1: p6, P2:p5};
				var line6 = {P1: p1, P2:p6};
				var out_of_circumference=false;
				var t=startt;
				var vt=t;
				if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
				while( vt<=endt){
					var tx = (1-t)*(1-t)*(1-t)*_P0.x + 3 *(1-t)*(1-t)* t *_P1.x + 3*(1-t)*t*t* _P2.x+ t*t*t*_P3.x ;
					var ty = (1-t)*(1-t)*(1-t)*_P0.y + 3 *(1-t)*(1-t)* t *_P1.y + 3*(1-t)*t*t* _P2.y+ t*t*t*_P3.y ;
					var tP = {x: tx, y: ty}; //console.log(tP);
					if ( tP.x <= _node.x - _node.rx || tP.x >= _node.x + _node.rx  || tP.y <= _node.y - _node.ry || tP.y >=  _node.y+_node.ry ){
						out_of_circumference=true;
					} else {
						var hexagon_y1;
						var hexagon_y2;
						var a1 = line1.P1.y;//intercept
						var b1 = (line1.P2.y - line1.P1.y)/(line1.P2.x - line1.P1.x);//slope
						var a6 = line6.P1.y;//intercept
						var b6 = (line6.P2.y - line6.P1.y)/(line6.P2.x - line6.P1.x);//slope
						var a3 = line3.P1.y;//intercept
						var b3 = (line3.P2.y - line3.P1.y)/(line3.P2.x - line3.P1.x);//slope
						var a4 = line4.P1.y;//intercept
						var b4 = (line4.P2.y - line4.P1.y)/(line4.P2.x - line4.P1.x);//slope
						if (tP.x <= _node.x - _node.rx/2) {
							hexagon_y1 = a1 +  b1 * (tP.x - line1.P1.x);
							hexagon_y2 = a6 +  b6 * (tP.x - line6.P1.x);
						} else if (tP.x >= _node.x + _node.rx/2){
							hexagon_y1 = a3 +  b3 * (tP.x - line3.P1.x);
							hexagon_y2 = a4 +  b4 * (tP.x - line4.P1.x);
						} else { 
							hexagon_y1=line2.P1.y;
							hexagon_y2 =line5.P1.y;
						}
							if (tP.y <= hexagon_y1 || tP.y >= hexagon_y2 ) {out_of_circumference=true;	}				
					}
					if ( out_of_circumference){
						Isfound = true;
						interP = tP;
						inter_t = t;
						t = stopt; //stop the for loop of t
						//generate a point next to the interP in order to draw the tangent line
						inter_t_out = inter_t + 50 * stept  ;
						var tx_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.x + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.x+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.x + inter_t_out*inter_t_out*inter_t_out*_P3.x ;
						var ty_out = (1-inter_t_out)*(1-inter_t_out)*(1-inter_t_out)*_P0.y + 3*(1-inter_t_out)*(1-inter_t_out)*inter_t_out*_P1.y+ 3*(1-inter_t_out)*inter_t_out*inter_t_out*_P2.y + inter_t_out*inter_t_out*inter_t_out*_P3.y ;

						interP_out = {x: tx_out, y: ty_out};	
					}				
						t = t + stept;
						vt=t;
						if (_witchnode==="endP") { vt= -1 * t;} else if (_witchnode==="startP") {vt=t;}
					
				}// end of while loop === for (var t=startt; t<= endt; t+= stept){}
			}
			break;
		default:	;
	}// end of switch (_node.type)
	var temp = {Isfound: Isfound, interP: interP, inter_t: inter_t, interP_out: interP_out, inter_t_out: inter_t_out};
	return temp;
}

//函数：对某bcurve2p找其与两节点周边的交点及切线
function generate_tangent_bcurve2p(_nodes,_bcurve2p){
		var temp1 = lookup_interP_with_oneNode_bcurve2p(_nodes,_bcurve2p,"startP");
		var temp2 = lookup_interP_with_oneNode_bcurve2p(_nodes,_bcurve2p,"endP");
		var Isfound1 = temp1.Isfound;
		var Isfound2 = temp2.Isfound;
		var interP1 = temp1.interP;
		var interP2 = temp2.interP;
		var inter_t1 = temp1.inter_t;
		var inter_t2 = temp2.inter_t;
		var interP_out1 = temp1.interP_out;
		var interP_out2 = temp2.interP_out;
		var inter_t_out1 = temp1.inter_t_out;
		var inter_t_out2 = temp2.inter_t_out;		
	
		var tangentline1 = {P1: interP_out1, P2: interP1};	
		var tangentline2 = {P1: interP_out2, P2: interP2};
		var t_tangent = {
			startid: _bcurve2p.startid,
			endid: _bcurve2p.endid,
			type: _bcurve2p.type,
			interP1: interP1,
			interP2: interP2,
			interP_out1: interP_out1,
			interP_out2: interP_out2,
			tangentline1: "M"+ interP_out1.x +","+ interP_out1.y+" "+"L"+interP1.x+","+interP1.y,
			tangentline2: "M"+ interP_out2.x +","+ interP_out2.y+" "+"L"+interP2.x+","+interP2.y			
		};
		return t_tangent;
}

//函数：对某bcurve3p找其与两节点周边的交点及切线
function generate_tangent_bcurve3p(_nodes,_bcurve3p){
		var temp1 = lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p,"startP");
		var temp2 = lookup_interP_with_oneNode_bcurve3p(_nodes,_bcurve3p,"endP");
		var Isfound1 = temp1.Isfound;
		var Isfound2 = temp2.Isfound;
		var interP1 = temp1.interP;
		var interP2 = temp2.interP;
		var inter_t1 = temp1.inter_t;
		var inter_t2 = temp2.inter_t;
		var interP_out1 = temp1.interP_out;
		var interP_out2 = temp2.interP_out;
		var inter_t_out1 = temp1.inter_t_out;
		var inter_t_out2 = temp2.inter_t_out;		
	
		var tangentline1 = {P1: interP_out1, P2: interP1};	
		var tangentline2 = {P1: interP_out2, P2: interP2};
		var t_tangent = {
			startid: _bcurve3p.nodeid,
			endid: _bcurve3p.nodeid,
			type: _bcurve3p.type,
			interP1: interP1,
			interP2: interP2,
			interP_out1: interP_out1,
			interP_out2: interP_out2,
			tangentline1: "M"+ interP_out1.x +","+ interP_out1.y+" "+"L"+interP1.x+","+interP1.y,
			tangentline2: "M"+ interP_out2.x +","+ interP_out2.y+" "+"L"+interP2.x+","+interP2.y	
		};
		return t_tangent;
}

//函数：对某bcurve找其与节点周边的交点及切线
function generate_tangent(_nodes,_bcurve){
	var t_tangent = null;
	if (_bcurve.power ===2) {
		t_tangent = generate_tangent_bcurve2p(_nodes,_bcurve);
	} else if (_bcurve.power === 3) {
		t_tangent = generate_tangent_bcurve3p(_nodes,_bcurve);
	}		
	return t_tangent;
}
//函数：对edges找其与两节点周边的交点及切线
function generate_tangents(_nodes,_edges){
	var tangents = [];
	for (var i =0; i< _edges.length; i++){
		var t_tangent = null;
		t_tangent = generate_tangent(_nodes,_edges[i]);
		tangents.push(t_tangent);
	}	
	return tangents;
}


//函数：当路径的节点位置移动而同时自动调整路径handleP的位置，以保持曲线的弧度不变
function generate_new_handleP_for_movednode(_nodes,_bcurve2p,_witchnode, _originP){
	var newhandleP = _bcurve2p.handleP;//the goal variable , set its default value
	var _i = matchnodeindex(_nodes,_bcurve2p.startid);
	var _j = matchnodeindex(_nodes,_bcurve2p.endid);
	var _startP = {x: _nodes[_i].x, y:_nodes[_i].y};
	var _endP= {x: _nodes[_j].x, y:_nodes[_j].y};
	var _handleP = _bcurve2p.handleP;
	switch(_witchnode){
		case "startP": {
			var angles = calculate_angles_of_triangle(_originP, _handleP, _endP);//the controlPs for bcurve2p as a triangle, keep the angles the same as before node moved
		} break;
		case "endP":{
			var angles = calculate_angles_of_triangle(_startP, _handleP, _originP);//the controlPs for bcurve2p as a triangle, keep the angles the same as before node moved
		} break;
		default: 
			var angles = calculate_angles_of_triangle(_originP, _handleP, _endP);//the controlPs for bcurve2p as a triangle, keep the angles the same as before node moved
	}
	if (angles.Is_success){
		//console.log("Is_success ");console.log(angles.Is_success);
		var angle_P0 = angles.angle_P0; //console.log("angle_P0 "+ angle_P0/Math.PI );
		var angle_P2 = angles.angle_P2; //console.log("angle_P2 "+ angle_P2/Math.PI  );
		var angle_P1 = angles.angle_P1; //console.log("angle_P1 "+ angle_P1/Math.PI );
		var angle_anticlockwise = angles.angle_anticlockwise;
		switch(_witchnode){
			case "startP":{	
				var origin_line_P0_P1 = {P1: _originP, P2:_handleP};
				var origin_length_P0_P1 = Math.sqrt((origin_line_P0_P1.P2.x - origin_line_P0_P1.P1.x)*(origin_line_P0_P1.P2.x - origin_line_P0_P1.P1.x)
												+(origin_line_P0_P1.P2.y - origin_line_P0_P1.P1.y)*(origin_line_P0_P1.P2.y - origin_line_P0_P1.P1.y));
				var origin_line_P0_P2 = {P1: _originP, P2: _endP};
				var origin_length_P0_P2 = Math.sqrt((origin_line_P0_P2.P2.x - origin_line_P0_P2.P1.x)*(origin_line_P0_P2.P2.x - origin_line_P0_P2.P1.x)
												+(origin_line_P0_P2.P2.y - origin_line_P0_P2.P1.y)*(origin_line_P0_P2.P2.y - origin_line_P0_P2.P1.y));
				var new_line_P0_P2 = {P1: _startP, P2: _endP};
				var new_length_P0_P2 = Math.sqrt((new_line_P0_P2.P2.x - new_line_P0_P2.P1.x)*(new_line_P0_P2.P2.x - new_line_P0_P2.P1.x)
												+(new_line_P0_P2.P2.y - new_line_P0_P2.P1.y)*(new_line_P0_P2.P2.y - new_line_P0_P2.P1.y));			
				var new_length_P0_P1 = origin_length_P0_P1 * new_length_P0_P2/origin_length_P0_P2;
				var temp_new_theta_P0_P2 = Math.acos( (new_line_P0_P2.P2.x -new_line_P0_P2.P1.x ) / new_length_P0_P2);//[0,PI] for acos()
				var new_theta_P0_P2;//[0, PI*2] 
				if (new_line_P0_P2.P2.y >= new_line_P0_P2.P1.y){
					new_theta_P0_P2 = temp_new_theta_P0_P2;
				} else {
					new_theta_P0_P2 = Math.PI*2 - temp_new_theta_P0_P2;
				}
				var new_theta_P0_P1;
				if(angle_anticlockwise) {//anticlockwise for P0 but clockwise for P2
					new_theta_P0_P1 = new_theta_P0_P2 + angle_P0;
				} else {//clockwise for P0 but anticlockwise for P2
					new_theta_P0_P1 = new_theta_P0_P2 - angle_P0;
				}
				var tempx = new_line_P0_P2.P1.x + new_length_P0_P1 * Math.cos(new_theta_P0_P1);
				var tempy = new_line_P0_P2.P1.y + new_length_P0_P1 * Math.sin(new_theta_P0_P1);
				newhandleP = {x: tempx, y: tempy};
				
			}
				break;
			case "endP"	:{
				var origin_line_P2_P1 = {P1: _originP, P2:_handleP};
				var origin_length_P2_P1 = Math.sqrt((origin_line_P2_P1.P2.x - origin_line_P2_P1.P1.x)*(origin_line_P2_P1.P2.x - origin_line_P2_P1.P1.x)
												+(origin_line_P2_P1.P2.y - origin_line_P2_P1.P1.y)*(origin_line_P2_P1.P2.y - origin_line_P2_P1.P1.y));
				var origin_line_P2_P0 = {P1: _originP, P2: _startP};
				var origin_length_P2_P0 = Math.sqrt((origin_line_P2_P0.P2.x - origin_line_P2_P0.P1.x)*(origin_line_P2_P0.P2.x - origin_line_P2_P0.P1.x)
												+(origin_line_P2_P0.P2.y - origin_line_P2_P0.P1.y)*(origin_line_P2_P0.P2.y - origin_line_P2_P0.P1.y));
				var new_line_P2_P0 = {P1: _endP, P2: _startP};
				var new_length_P2_P0 = Math.sqrt((new_line_P2_P0.P2.x - new_line_P2_P0.P1.x)*(new_line_P2_P0.P2.x - new_line_P2_P0.P1.x)
												+(new_line_P2_P0.P2.y - new_line_P2_P0.P1.y)*(new_line_P2_P0.P2.y - new_line_P2_P0.P1.y));			
				var new_length_P2_P1 = origin_length_P2_P1 * new_length_P2_P0/origin_length_P2_P0;
					//console.log("originendP "+ _originP.x +" " + _originP.y);
					//console.log("newendP "+ _endP.x +" " + _endP.y);
					//console.log("new_length_P2_P0 "+new_length_P2_P0);
					//console.log("new_length_P2_P1 "+new_length_P2_P1);
				var temp_new_theta_P2_P0 = Math.acos( (new_line_P2_P0.P2.x -new_line_P2_P0.P1.x ) / new_length_P2_P0);//[0,PI] for acos()
				var new_theta_P2_P0;//[0, PI*2] 
				if (new_line_P2_P0.P2.y>= new_line_P2_P0.P1.y){
					new_theta_P2_P0 = temp_new_theta_P2_P0;
				} else {
					new_theta_P2_P0 = Math.PI*2 - temp_new_theta_P2_P0;
				}
				//console.log("new_theta_P2_P0 "+ new_theta_P2_P0/Math.PI );
				var new_theta_P2_P1;
				if(angle_anticlockwise) {//anticlockwise for P0 but clockwise for P2
					new_theta_P2_P1 = new_theta_P2_P0 - angle_P2;
				} else {//clockwise for P0 but anticlockwise for P2
					new_theta_P2_P1 = new_theta_P2_P0 + angle_P2;
				}
				//console.log("new_theta_P2_P1 "+ new_theta_P2_P1/Math.PI );
				var tempx = new_line_P2_P0.P1.x + new_length_P2_P1 * Math.cos(new_theta_P2_P1);
				var tempy = new_line_P2_P0.P1.y + new_length_P2_P1 * Math.sin(new_theta_P2_P1);
				newhandleP = {x: tempx, y: tempy};
				//console.log("newhandleP "); console.log(newhandleP);
			}
				break;
			default:;
		}// end switch
	}// end if (alpha_beta.Is_success)
	
	return newhandleP;
}

